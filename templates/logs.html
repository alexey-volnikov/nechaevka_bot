<!doctype html> <!-- Объявляем тип документа -->
<html lang="ru"> <!-- Устанавливаем язык страницы -->
<head> <!-- Начало шапки -->
  <meta charset="UTF-8" /> <!-- Кодировка -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- Адаптивность -->
  <title>Полные логи сообщений</title> <!-- Заголовок вкладки -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" /> <!-- Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com" /> <!-- Предзагрузка шрифтов -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> <!-- Кросс-домен для шрифтов -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" /> <!-- Шрифт Inter -->
  <style> /* Начало пользовательских стилей */
    body { background: #0f172a; color: #e2e8f0; font-family: "Inter", system-ui, -apple-system, sans-serif; } /* Фон и текст */
    .glass { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 18px; backdrop-filter: blur(10px); } /* Стеклянный стиль */
    .badge-soft { background: rgba(99, 102, 241, 0.15); color: #c7d2fe; border: 1px solid rgba(99, 102, 241, 0.35); } /* Мягкий бейдж */
    .table > :not(caption) > * > * { background-color: transparent; color: #e2e8f0; } /* Прозрачные ячейки */
    .table-striped > tbody > tr:nth-of-type(odd) > * { background: rgba(255, 255, 255, 0.03); } /* Полосатость */
    .shadow-soft { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25); } /* Мягкая тень */
    .service-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 12px; font-size: 12px; } /* Пилюля статуса */
    .service-pill.info { background: rgba(56, 189, 248, 0.2); color: #bae6fd; border: 1px solid rgba(56, 189, 248, 0.5); } /* Цвет инфо */
    .service-pill.warning { background: rgba(234, 179, 8, 0.2); color: #fef08a; border: 1px solid rgba(234, 179, 8, 0.5); } /* Цвет предупреждения */
    .service-pill.error { background: rgba(248, 113, 113, 0.2); color: #fecdd3; border: 1px solid rgba(248, 113, 113, 0.5); } /* Цвет ошибки */
    .service-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; } /* Точка индикации */
    .service-dot.info { background: #38bdf8; } /* Цвет точки инфо */
    .service-dot.warning { background: #fbbf24; } /* Цвет точки предупреждения */
    .service-dot.error { background: #f87171; } /* Цвет точки ошибки */
    .avatar-inline { width: 1.6em; height: 1.6em; border-radius: 999px; object-fit: cover; flex-shrink: 0; } /* Класс компактной аватарки */
    .attachment-pill { display: inline-flex; gap: 6px; align-items: center; padding: 4px 10px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.05); color: #e2e8f0; font-size: 12px; text-decoration: none; } /* Пилюля вложения */
    .attachment-pill:hover { text-decoration: none; background: rgba(255, 255, 255, 0.08); } /* Подсветка вложения */
    .attachment-photo { border-color: rgba(59, 130, 246, 0.5); color: #bfdbfe; } /* Цвет фото */
    .attachment-video { border-color: rgba(244, 114, 182, 0.5); color: #fbcfe8; } /* Цвет видео */
    .attachment-doc { border-color: rgba(74, 222, 128, 0.5); color: #bbf7d0; } /* Цвет документов */
    .attachment-audio { border-color: rgba(56, 189, 248, 0.5); color: #bae6fd; } /* Цвет аудио */
    .attachment-sticker { border-color: rgba(248, 180, 0, 0.6); color: #fef08a; } /* Цвет стикеров */
    .attachment-wall { border-color: rgba(236, 72, 153, 0.6); color: #fbcfe8; } /* Цвет постов */
    .attachment-link { border-color: rgba(14, 165, 233, 0.5); color: #bae6fd; } /* Цвет ссылок */
    .attachment-generic { border-color: rgba(148, 163, 184, 0.5); color: #e2e8f0; } /* Цвет прочих вложений */
    .attachment-group { display: flex; flex-wrap: wrap; gap: 6px; } /* Группа вложений */
    .copy-block { display: flex; flex-direction: column; gap: 4px; padding: 6px 10px; border-radius: 12px; border: 1px dashed rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.02); } /* Блок репоста */
    .copy-header { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cbd5e1; } /* Заголовок репоста */
    .copy-attachments { display: flex; flex-wrap: wrap; gap: 6px; } /* Вложения репоста */
    .content-cell { display: flex; flex-direction: column; gap: 6px; } /* Ячейка контента */
    .gallery-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 16px; } /* Фон модалки */
    .gallery-body { background: #0b1220; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; max-width: 900px; width: 100%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35); display: flex; flex-direction: column; gap: 12px; padding: 16px; } /* Корпус модалки */
    .gallery-media { position: relative; min-height: 320px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.03); border-radius: 12px; overflow: hidden; } /* Блок медиа */
    .gallery-media img, .gallery-media video { max-height: 540px; width: 100%; object-fit: contain; border-radius: 12px; background: #0b1220; } /* Медиа в модалке */
    .gallery-actions { display: flex; align-items: center; justify-content: space-between; gap: 12px; } /* Панель кнопок */
    .gallery-meta { display: flex; flex-direction: column; gap: 4px; font-size: 14px; color: #cbd5e1; } /* Текст описания */
    .gallery-nav-btn { min-width: 42px; } /* Минимальная ширина кнопок навигации */
    .gallery-thumb { margin: 2px; } /* Отступы кнопок миниатюр */
    .gallery-thumb.active { border-width: 2px !important; } /* Подсветка активного элемента */
  </style> <!-- Конец стилей -->
</head> <!-- Конец шапки -->
<body class="pb-5"> <!-- Тело страницы -->
  <div class="container py-4"> <!-- Контейнер -->
    <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-3 mb-4"> <!-- Заголовок страницы -->
      <div> <!-- Левая часть -->
        <div class="d-inline-flex align-items-center gap-2 mb-2"> <!-- Бейдж -->
          <span class="badge-soft badge rounded-pill"> <!-- Обертка бейджа -->
            Полные логи <!-- Подпись -->
          </span> <!-- Конец бейджа -->
        </div> <!-- Конец блока бейджа -->
        <h1 class="fw-bold mb-1">Все сообщения</h1> <!-- Заголовок -->
        <p class="text-secondary mb-0">До 1000 последних записей с фильтрацией по чатам.</p> <!-- Подзаголовок -->
      </div> <!-- Конец левой части -->
      <div class="d-flex flex-wrap gap-2"> <!-- Правая часть с кнопками -->
        <a href="/" class="btn btn-outline-light">Вернуться к дашборду</a> <!-- Кнопка назад -->
        <button id="refresh-btn" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
        <button id="clear-btn" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки логов сообщений -->
      </div> <!-- Конец правой части -->
    </div> <!-- Конец заголовка страницы -->

    <ul class="nav nav-pills mb-4 gap-2 flex-wrap"> <!-- Панель вкладок -->
      <li class="nav-item"> <!-- Пункт вкладки сообщений -->
        <button id="messages-tab-btn" class="nav-link active text-light bg-primary" type="button">Логи сообщений</button> <!-- Кнопка вкладки сообщений -->
      </li> <!-- Конец пункта вкладки сообщений -->
      <li class="nav-item"> <!-- Пункт вкладки сервисных логов -->
        <button id="service-tab-btn" class="nav-link text-light bg-dark border border-secondary" type="button">Сервисные логи</button> <!-- Кнопка вкладки сервисных логов -->
      </li> <!-- Конец пункта вкладки сервисных логов -->
    </ul> <!-- Конец панели вкладок -->

    <div id="messages-section" class="d-block"> <!-- Секция логов сообщений -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров -->
        <form id="filters-form" class="row g-3 align-items-end"> <!-- Форма фильтров -->
          <div class="col-12 col-md-5"> <!-- Колонка селектора чатов -->
            <label class="form-label text-secondary small" for="peer-filter">Фильтр по peer_id</label> <!-- Подпись -->
            <select id="peer-filter" name="peer_id" class="form-select bg-dark text-light border-secondary"> <!-- Селектор -->
              <option value="">Все чаты</option> <!-- Опция по умолчанию -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-3"> <!-- Колонка лимита -->
            <label class="form-label text-secondary small" for="limit-input">Лимит записей (до 1000)</label> <!-- Подпись -->
            <input type="number" id="limit-input" name="limit" class="form-control bg-dark text-light border-secondary" min="1" max="1000" /> <!-- Поле лимита -->
          </div> <!-- Конец колонки лимита -->
          <div class="col-12 col-md-4 d-flex gap-2"> <!-- Колонка кнопок -->
            <button type="submit" class="btn btn-primary flex-grow-1">Применить фильтр</button> <!-- Кнопка отправки -->
            <a href="/logs/full" class="btn btn-outline-light">Сбросить</a> <!-- Кнопка сброса -->
          </div> <!-- Конец колонки кнопок -->
        </form> <!-- Конец формы -->
      </div> <!-- Конец блока фильтров -->

      <div class="glass shadow-soft p-4"> <!-- Блок таблицы -->
        <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок таблицы -->
          <div> <!-- Левая часть -->
            <div class="card-title mb-1">Логи сообщений</div> <!-- Название -->
            <div class="text-secondary small">Содержимое базы с именами, чатами и вложениями.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center gap-2"> <!-- Контейнер бейджей -->
            <span class="badge-soft badge rounded-pill" id="timezone-hint" title="">Локальное время</span> <!-- Бейдж с подсказкой о таймзоне -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
          </div> <!-- Конец контейнера бейджей -->
        </div> <!-- Конец заголовка таблицы -->
        <div class="table-responsive"> <!-- Обертка таблицы -->
          <table class="table table-striped align-middle mb-0"> <!-- Таблица -->
            <thead class="text-secondary"> <!-- Шапка -->
              <tr> <!-- Строка заголовков -->
                <th>Время</th> <!-- Колонка времени -->
                <th>Чат</th> <!-- Колонка чата -->
                <th>Отправитель</th> <!-- Колонка автора -->
                <th>Бот?</th> <!-- Колонка бота -->
                <th>Ответ</th> <!-- Колонка ответа -->
                <th>Вложения</th> <!-- Колонка вложений -->
                <th>Текст</th> <!-- Колонка текста -->
                <th>ID VK</th> <!-- Колонка ID сообщения во VK -->
                <th>Запись</th> <!-- Колонка ID в базе -->
                <th>Действия</th> <!-- Колонка действий -->
              </tr> <!-- Конец строки заголовков -->
            </thead> <!-- Конец шапки -->
            <tbody id="logs-body"> <!-- Тело таблицы -->
              <tr> <!-- Плейсхолдер -->
                <td colspan="10" class="text-secondary">Нет данных</td> <!-- Текст плейсхолдера -->
              </tr> <!-- Конец плейсхолдера -->
            </tbody> <!-- Конец тела таблицы -->
          </table> <!-- Конец таблицы -->
        </div> <!-- Конец обертки таблицы -->
      </div> <!-- Конец блока таблицы -->
    </div> <!-- Конец секции логов сообщений -->

    <div id="service-section" class="d-none"> <!-- Секция сервисных логов -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров сервисных логов -->
        <form id="service-filters" class="row g-3 align-items-end"> <!-- Форма фильтра сервисных логов -->
          <div class="col-12 col-md-4"> <!-- Колонка типа события -->
            <label class="form-label text-secondary small" for="service-type">Тип оповещения</label> <!-- Подпись -->
            <select id="service-type" class="form-select bg-dark text-light border-secondary"> <!-- Селектор типа -->
              <option value="">Все</option> <!-- Опция все -->
              <option value="important">Важные (warning+error)</option> <!-- Опция важных -->
              <option value="error">Только ошибки</option> <!-- Опция ошибок -->
              <option value="warning">Предупреждения</option> <!-- Опция предупреждений -->
              <option value="info">Информационные</option> <!-- Опция инфо -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-3"> <!-- Колонка лимита -->
            <label class="form-label text-secondary small" for="service-limit">Лимит строк</label> <!-- Подпись -->
            <input type="number" id="service-limit" class="form-control bg-dark text-light border-secondary" min="1" max="200" value="50" /> <!-- Поле лимита -->
          </div> <!-- Конец колонки лимита -->
          <div class="col-12 col-md-5"> <!-- Колонка пагинации -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер кнопок -->
              <button id="service-prev" class="btn btn-outline-light flex-grow-1" type="button">Назад</button> <!-- Кнопка назад -->
              <button id="service-next" class="btn btn-outline-light flex-grow-1" type="button">Вперед</button> <!-- Кнопка вперед -->
              <span id="service-page" class="text-secondary small">—</span> <!-- Подпись страницы -->
            </div> <!-- Конец контейнера -->
          </div> <!-- Конец колонки -->
        </form> <!-- Конец формы фильтра -->
      </div> <!-- Конец блока фильтров сервисных логов -->

      <div id="service-alerts" class="glass shadow-soft p-4"> <!-- Блок сервисных оповещений -->
        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-3"> <!-- Заголовок блока -->
          <div> <!-- Левая часть заголовка -->
            <div class="card-title mb-1">Сервисные оповещения</div> <!-- Заголовок текста -->
            <div class="text-secondary small">Ошибки, предупреждения и информирование о работе сервиса.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center flex-wrap gap-2"> <!-- Правая часть с элементами -->
            <span class="badge-soft badge rounded-pill" id="service-timezone-hint" title="">Локальное время</span> <!-- Бейдж подсказки таймзоны -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
            <div class="d-flex flex-wrap gap-2"> <!-- Группа кнопок -->
              <button id="service-refresh" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
              <button id="service-clear" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки -->
            </div> <!-- Конец группы кнопок -->
          </div> <!-- Конец правой части -->
        </div> <!-- Конец заголовка блока -->
        <div class="table-responsive"> <!-- Обертка таблицы сервисных логов -->
          <table class="table table-striped align-middle mb-0"> <!-- Таблица сервисных логов -->
            <thead class="text-secondary"> <!-- Заголовок таблицы -->
              <tr> <!-- Строка заголовка -->
                <th>Время</th> <!-- Колонка времени -->
                <th>Тип</th> <!-- Колонка типа -->
                <th>Код</th> <!-- Колонка кода -->
                <th>Пояснение</th> <!-- Колонка пояснения -->
                <th>Сообщение</th> <!-- Колонка текста -->
              </tr> <!-- Конец строки -->
            </thead> <!-- Конец шапки -->
            <tbody id="service-logs-body"> <!-- Тело таблицы сервисных логов -->
              <tr> <!-- Плейсхолдер -->
                <td colspan="5" class="text-secondary">Нет данных</td> <!-- Текст плейсхолдера -->
              </tr> <!-- Конец плейсхолдера -->
            </tbody> <!-- Конец тела -->
          </table> <!-- Конец таблицы -->
        </div> <!-- Конец обертки -->
      </div> <!-- Конец блока сервисных оповещений -->
    </div> <!-- Конец секции сервисных логов -->
  </div> <!-- Конец контейнера -->

  {% include 'partials/gallery.html' %} <!-- Подключаем общую разметку модального окна галереи -->

  <script> // Начало скрипта
    const initialLogs = {{ initial_logs|tojson }}; // Стартовые логи из шаблона
    const initialPeers = {{ initial_peers|tojson }}; // Стартовый список чатов
    const initialPeerId = {{ initial_peer_id|tojson }}; // Стартовый peer_id
    const initialLimit = {{ initial_limit|tojson }}; // Стартовый лимит
    const initialServiceLogs = {{ initial_service_logs|tojson }}; // Стартовые сервисные логи

    const logsBody = document.getElementById('logs-body'); // Тело таблицы логов
    const peerFilter = document.getElementById('peer-filter'); // Селектор чатов
    const limitInput = document.getElementById('limit-input'); // Поле лимита
    const refreshBtn = document.getElementById('refresh-btn'); // Кнопка обновления
    const clearBtn = document.getElementById('clear-btn'); // Кнопка очистки логов сообщений
    const filtersForm = document.getElementById('filters-form'); // Форма фильтров
    const serviceBody = document.getElementById('service-logs-body'); // Тело таблицы сервисных логов
    const serviceTypeSelect = document.getElementById('service-type'); // Селектор типа сервисных событий
    const serviceLimitInput = document.getElementById('service-limit'); // Поле лимита сервисных событий
    const servicePrevBtn = document.getElementById('service-prev'); // Кнопка назад
    const serviceNextBtn = document.getElementById('service-next'); // Кнопка вперед
    const servicePageLabel = document.getElementById('service-page'); // Текст пагинации
    const serviceRefreshBtn = document.getElementById('service-refresh'); // Кнопка обновления сервисных логов
    const serviceClearBtn = document.getElementById('service-clear'); // Кнопка очистки сервисных логов
    const messagesSection = document.getElementById('messages-section'); // Секция логов сообщений
    const serviceSection = document.getElementById('service-section'); // Секция сервисных логов
    const messagesTabBtn = document.getElementById('messages-tab-btn'); // Кнопка вкладки сообщений
    const serviceTabBtn = document.getElementById('service-tab-btn'); // Кнопка вкладки сервисных логов
    const galleryModal = document.getElementById('gallery-modal'); // Фон модалки галереи
    const galleryMedia = document.getElementById('gallery-media'); // Блок медиа в модалке
    const galleryStrip = document.getElementById('gallery-strip'); // Полоса миниатюр для вложений
    const galleryCaption = document.getElementById('gallery-caption'); // Подпись файла
    const galleryOrigin = document.getElementById('gallery-origin'); // Источник файла
    const galleryLinks = document.getElementById('gallery-links'); // Блок ссылок
    const galleryClose = document.getElementById('gallery-close'); // Кнопка закрытия галереи
    const galleryPrev = document.getElementById('gallery-prev'); // Кнопка предыдущего элемента
    const galleryNext = document.getElementById('gallery-next'); // Кнопка следующего элемента
    const galleryStore = {}; // Хранилище вложений для галереи
    let currentGalleryKey = null; // Текущий ключ активной галереи
    let currentGalleryIndex = 0; // Текущий индекс в активной галерее
    let galleryCounter = 0; // Счетчик для генерации ключей

    function resetGalleryStorePreserveActive() { // Очищаем хранилище, но сохраняем открытую галерею
      const modalOpen = galleryModal.style.display === 'flex'; // Проверяем, открыта ли модалка
      const preservedKey = modalOpen ? currentGalleryKey : null; // Сохраняем активный ключ
      const preservedValue = preservedKey ? galleryStore[preservedKey] : null; // Запоминаем активную галерею
      Object.keys(galleryStore).forEach((key) => { // Перебираем ключи хранилища
        if (!preservedKey || key !== preservedKey) { // Если ключ не активен
          delete galleryStore[key]; // Удаляем запись
        } // Конец проверки
      }); // Конец очистки
      if (preservedKey && preservedValue) { // Если есть активная галерея
        galleryStore[preservedKey] = preservedValue; // Возвращаем её обратно
      } // Конец восстановления
    } // Конец функции сохранения активной галереи при очистке
    let serviceOffset = 0; // Текущее смещение
    let serviceTotal = 0; // Общее количество сервисных событий
    const serviceHashRequested = window.location.hash.includes('service-alerts'); // Флаг наличия якоря сервисных логов в URL
    if (serviceHashRequested) { // Если в адресе сразу указаны сервисные логи
      serviceTypeSelect.value = 'important'; // Ставим фильтр «Важные» до загрузки данных
    } // Конец предварительной установки фильтра

    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions(); // Читаем параметры локальной таймзоны
    const timezoneOffsetMinutes = new Date().getTimezoneOffset(); // Получаем смещение в минутах относительно UTC
    const timezoneOffsetSign = timezoneOffsetMinutes <= 0 ? '+' : '-'; // Определяем знак смещения
    const timezoneOffsetHours = String(Math.floor(Math.abs(timezoneOffsetMinutes) / 60)).padStart(2, '0'); // Вычисляем часы смещения
    const timezoneOffsetRestMinutes = String(Math.abs(timezoneOffsetMinutes) % 60).padStart(2, '0'); // Вычисляем минуты смещения
    const timezoneLabel = `UTC${timezoneOffsetSign}${timezoneOffsetHours}:${timezoneOffsetRestMinutes} (${timezoneInfo.timeZone || 'локальное время'})`; // Формируем строку подсказки
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: timezoneInfo.timeZone, timeZoneName: 'short' }); // Настраиваем форматер локального времени

    document.getElementById('timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сообщений
    document.getElementById('service-timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сервисных логов

    function formatDateTime(value) { // Функция форматирования даты в локальное время
      const parsed = value ? new Date(value) : null; // Парсим строку даты
      return parsed && !Number.isNaN(parsed.valueOf()) ? timeFormatter.format(parsed) : '—'; // Возвращаем отформатированное значение или тире
    } // Конец функции форматирования

    function buildAvatarLabel(label, avatarUrl) { // Функция построения подписи с аватаркой
      const safeLabel = label || '—'; // Определяем подпись, если значения нет
      if (avatarUrl) { // Если есть ссылка на аватар
        return `<span class="d-inline-flex align-items-center gap-2"><img src="${avatarUrl}" alt="Аватар" class="avatar-inline" loading="lazy" /> <span>${safeLabel}</span></span>`; // Возвращаем подпись с картинкой
      } // Конец проверки аватара
      return safeLabel; // Если аватар отсутствует, возвращаем только текст
    } // Конец функции построения подписи

    function buildReplyPreview(reply, peerId) { // Функция сборки ячейки ответа
      if (!reply || (!reply.id && !reply.text && !reply.from_id)) { // Проверяем наличие полезных данных
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер при отсутствии ответа
      } // Конец проверки наличия ответа
      const replyId = reply.id ?? '—'; // Определяем ID исходного сообщения
      const replyText = reply.text ? reply.text.slice(0, 120) : 'Без текста'; // Готовим превью текста
      const replyAuthorLabel = reply.from_name ? `${reply.from_name} (ID: ${reply.from_id ?? '—'})` : reply.from_id ? `ID: ${reply.from_id}` : 'Автор неизвестен'; // Формируем подпись автора ответа
      const replyAuthorCell = buildAvatarLabel(replyAuthorLabel, reply.from_avatar); // Готовим подпись автора с аватаркой
      const replyLink = reply.id && peerId ? `<a href="https://vk.com/im?sel=${peerId}&msgid=${reply.id}" target="_blank" rel="noopener noreferrer">#${reply.id}</a>` : `#${replyId}`; // Собираем ссылку на исходное сообщение
      const replyAttachmentsCount = Array.isArray(reply.attachments) ? reply.attachments.length : 0; // Считаем вложения исходного сообщения
      const replyAttachmentsLabel = replyAttachmentsCount ? `${replyAttachmentsCount} влож.` : 'Без вложений'; // Формируем подпись вложений
      return `<div class="d-flex flex-column gap-1"><div class="d-flex align-items-center gap-2">${replyLink}<span class="text-secondary small">${replyAttachmentsLabel}</span></div><div class="text-secondary small">${replyText}</div><div class="text-secondary small">${replyAuthorCell}</div></div>`; // Возвращаем HTML ячейки
    } // Конец функции сборки ответа

    const attachmentTypeLabels = { photo: 'Фото', video: 'Видео', doc: 'Документ', audio_message: 'Голос', audio: 'Аудио', link: 'Ссылка', sticker: 'Стикер', wall: 'Пост', wall_reply: 'Комментарий', market: 'Товар', gift: 'Подарок', story: 'История', graffiti: 'Граффити', podcast: 'Подкаст', share: 'Репост', file: 'Файл' }; // Человекочитаемые подписи типов
    const attachmentTypeClasses = { photo: 'attachment-photo', video: 'attachment-video', doc: 'attachment-doc', audio: 'attachment-audio', audio_message: 'attachment-audio', link: 'attachment-link', wall: 'attachment-wall', wall_reply: 'attachment-wall', sticker: 'attachment-sticker', default: 'attachment-generic' }; // Классы подсветки типов

    function normalizeAttachmentLink(att) { // Функция получения ссылки на вложение
      if (!att || typeof att !== 'object') { // Проверяем формат объекта
        return null; // Возвращаем пустое значение
      } // Конец проверки
      return att.public_url || att.download_url || att.url || null; // Возвращаем ссылку или null
    } // Конец функции

    function isVideoType(type) { // Проверяем, относится ли тип к видео
      return type === 'video' || type === 'story'; // Считаем видео и истории видеоконтентом
    } // Конец функции проверки видео

    function attachmentSignature(att) { // Формируем сигнатуру вложения для устранения дублей
      if (!att || typeof att !== 'object') { // Проверяем корректность объекта
        return null; // Возвращаем пустое значение при ошибке
      } // Конец проверки
      const type = att.type || (att.photo ? 'photo' : att.video ? 'video' : att.doc ? 'doc' : null); // Определяем тип вложения
      const nested = type && att[type] && typeof att[type] === 'object' ? att[type] : {}; // Берем вложенный блок по типу
      const owner = nested.owner_id; // Читаем owner_id вложения
      const id = nested.id; // Читаем id вложения
      const access = nested.access_key; // Читаем access_key вложения
      if (owner !== undefined && id !== undefined) { // Проверяем наличие идентификаторов
        return `${type}:${owner}_${id}_${access || ''}`; // Формируем сигнатуру по ID
      } // Конец проверки идентификаторов
      const url = normalizeAttachmentLink(att) || att.public_url || att.download_url || att.url; // Пытаемся взять ссылку вложения
      if (url) { // Если ссылка найдена
        return `${type || 'file'}:${url}`; // Формируем сигнатуру по ссылке
      } // Конец проверки ссылки
      try { // Пытаемся сериализовать объект
        return JSON.stringify(att); // Возвращаем сериализованную сигнатуру
      } catch (e) { // Обрабатываем ошибки сериализации
        return null; // Возвращаем пустое значение при исключении
      } // Конец блока обработки ошибок
    } // Конец функции формирования сигнатуры

    function collectAttachmentItems(list, origin, bucket, seen) { // Собираем вложения в плоский список для галереи
      if (!Array.isArray(list)) { // Проверяем формат входных данных
        return; // Выходим, если передан не список
      } // Конец проверки
      list.forEach((att) => { // Перебираем вложения
        if (!att || typeof att !== 'object') { // Проверяем корректность элемента
          return; // Пропускаем некорректные записи
        } // Конец проверки
        const signature = attachmentSignature(att); // Вычисляем сигнатуру вложения
        if (signature && seen && seen.has(signature)) { // Проверяем, не попадался ли дубликат
          return; // Пропускаем дубликат
        } // Конец проверки дубля
        const url = normalizeAttachmentLink(att); // Получаем ссылку на вложение
        if (!url) { // Если ссылки нет
          return; // Пропускаем элемент
        } // Конец проверки наличия ссылки
        const type = att.type || 'file'; // Определяем тип вложения
        const caption = att.title || att.name || att.doc?.title || att.link?.title || att.photo?.text || att.description || ''; // Подбираем подпись
        if (signature && seen) { // Проверяем наличие набора дублей
          seen.add(signature); // Сохраняем сигнатуру, чтобы убрать повторы
        } // Конец добавления сигнатуры
        bucket.push({ url, type, caption, origin: origin || 'Сообщение' }); // Добавляем элемент в итоговый список
      }); // Конец перебора
    } // Конец функции сборки вложений

    function mergeAttachmentLists(primary, fallback) { // Объединяем вложения из основного блока и payload без дублей
      const result = []; // Итоговый массив объединенных вложений
      const seen = new Set(); // Набор ключей для отслеживания дублей
      const pushUnique = (item) => { // Вспомогательная функция добавления элемента
        if (!item || typeof item !== 'object') { // Проверяем корректность вложения
          return; // Пропускаем некорректные данные
        } // Конец проверки
        const signature = attachmentSignature(item); // Формируем сигнатуру вложения
        if (signature && seen.has(signature)) { // Проверяем, не добавляли ли этот элемент
          return; // Пропускаем дубликат
        } // Конец проверки дубля
        if (signature) { // Проверяем наличие сигнатуры
          seen.add(signature); // Запоминаем сигнатуру
        } // Конец добавления сигнатуры
        result.push(item); // Добавляем вложение в итоговый список
      }; // Конец вспомогательной функции
      if (Array.isArray(primary)) { // Проверяем основной список вложений
        primary.forEach(pushUnique); // Добавляем элементы основного списка
      } // Конец проверки основного списка
      if (Array.isArray(fallback)) { // Проверяем запасной список из payload
        fallback.forEach(pushUnique); // Добавляем вложения из payload
      } // Конец проверки fallback
      return result; // Возвращаем объединенный список
    } // Конец функции объединения

    function extractAttachments(message) { // Извлекаем и объединяем вложения из основного блока и payload
      const primary = Array.isArray(message?.attachments) ? message.attachments : []; // Забираем вложения сообщения
      const fallback = message?.payload && Array.isArray(message.payload.attachments) ? message.payload.attachments : []; // Забираем вложения из payload
      return mergeAttachmentLists(primary, fallback); // Возвращаем объединенный список без дублей
    } // Конец функции извлечения вложений

    function extractCopyHistory(message) { // Извлекаем copy_history из сообщения или payload
      const primary = Array.isArray(message?.copy_history) ? message.copy_history : []; // Основной список репостов
      const fallback = message?.payload && Array.isArray(message.payload.copy_history) ? message.payload.copy_history : []; // Запасной список из payload
      return [...primary, ...fallback].filter((entry) => entry && typeof entry === 'object'); // Объединяем списки и фильтруем корректные записи
    } // Конец функции извлечения copy_history

    function countAttachmentList(list) { // Считает количество вложений в списке
      if (!Array.isArray(list)) { // Проверяем формат списка
        return 0; // Возвращаем ноль при ошибке
      } // Конец проверки
      return list.filter((item) => item && typeof item === 'object').length; // Считаем только объекты вложений
    } // Конец функции подсчета вложений

    function countCopyHistoryAttachments(entries) { // Рекурсивно считает вложения в copy_history
      if (!Array.isArray(entries)) { // Проверяем формат входных данных
        return 0; // Возвращаем ноль при ошибке формата
      } // Конец проверки
      return entries.reduce((acc, entry) => { // Накопительно обрабатываем репосты
        if (!entry || typeof entry !== 'object') { // Проверяем тип записи
          return acc; // Возвращаем счетчик без изменений
        } // Конец проверки
        const selfCount = countAttachmentList(entry.attachments); // Считаем вложения самого репоста
        const nestedCount = countCopyHistoryAttachments(entry.copy_history); // Считаем вложения вложенных репостов
        return acc + selfCount + nestedCount; // Складываем результаты
      }, 0); // Начальное значение счетчика
    } // Конец функции рекурсивного подсчета

    function findFirstAttachmentLink(list) { // Ищем первую ссылку в списке вложений
      if (!Array.isArray(list)) { // Проверяем формат списка
        return null; // Возвращаем null при ошибке
      } // Конец проверки
      for (const att of list) { // Перебираем вложения
        const link = normalizeAttachmentLink(att); // Получаем ссылку на вложение
        if (link) { // Если ссылка найдена
          return link; // Возвращаем найденную ссылку
        } // Конец проверки
      } // Конец цикла
      return null; // Возвращаем null, если ничего не нашли
    } // Конец функции поиска ссылки

    function findFirstCopyHistoryLink(entries) { // Рекурсивно ищем ссылку во вложениях copy_history
      if (!Array.isArray(entries)) { // Проверяем формат входных данных
        return null; // Возвращаем null при ошибке
      } // Конец проверки
      for (const entry of entries) { // Перебираем репосты
        if (!entry || typeof entry !== 'object') { // Проверяем тип записи
          continue; // Пропускаем некорректные элементы
        } // Конец проверки
        const direct = findFirstAttachmentLink(entry.attachments); // Ищем ссылку в вложениях репоста
        if (direct) { // Если ссылка найдена
          return direct; // Возвращаем найденную ссылку
        } // Конец проверки
        const nested = findFirstCopyHistoryLink(entry.copy_history); // Ищем ссылку во вложенных репостах
        if (nested) { // Если ссылка найдена
          return nested; // Возвращаем найденную ссылку
        } // Конец проверки
      } // Конец цикла по репостам
      return null; // Возвращаем null, если ссылки не найдены
    } // Конец функции поиска ссылки в copy_history

    function collectCopyHistoryItems(entries, origin, bucket, seen) { // Рекурсивно собираем вложения из репостов
      if (!Array.isArray(entries)) { // Проверяем формат
        return; // Выходим при неверном типе
      } // Конец проверки
      entries.forEach((entry) => { // Перебираем репосты
        if (!entry || typeof entry !== 'object') { // Проверяем тип записи
          return; // Пропускаем неверные элементы
        } // Конец проверки типа
        const entryOrigin = entry.from_name ? `Репост от ${entry.from_name}` : origin || 'Репост'; // Формируем источник
        collectAttachmentItems(entry.attachments || [], entryOrigin, bucket, seen); // Собираем вложения репоста без дублей
        if (Array.isArray(entry.copy_history) && entry.copy_history.length) { // Проверяем наличие вложенных репостов
          collectCopyHistoryItems(entry.copy_history, entryOrigin, bucket, seen); // Рекурсивно собираем вложения без дублей
        } // Конец проверки вложенных репостов
      }); // Конец перебора репостов
    } // Конец функции сбора вложений из copy_history

    function registerGallery(message, galleryKey) { // Регистрируем галерею для конкретного сообщения
      if (!galleryKey) { // Проверяем наличие ключа
        return; // Выходим, если ключ не передан
      } // Конец проверки ключа
      const bucket = []; // Готовим список вложений
      const seen = new Set(); // Готовим набор сигнатур для удаления дублей
      const attachments = extractAttachments(message); // Забираем вложения из сообщения или payload
      const copyHistory = extractCopyHistory(message); // Забираем copy_history из сообщения или payload
      const authorLabel = message.from_name ? `${message.from_name} (ID: ${message.from_id ?? '—'})` : `ID: ${message.from_id ?? '—'}`; // Подпись автора
      const peerLabel = message.peer_title ? `${message.peer_title} (ID: ${message.peer_id ?? '—'})` : `ID: ${message.peer_id ?? '—'}`; // Подпись чата
      const meta = { author: authorLabel, peer: peerLabel, text: message.text || 'Без текста' }; // Метаданные для модалки
      collectAttachmentItems(attachments, 'Сообщение', bucket, seen); // Собираем вложения сообщения без дублей
      collectCopyHistoryItems(copyHistory, 'Репост', bucket, seen); // Собираем вложения репостов без дублей
      if (!bucket.length) { // Если нет вложений
        return; // Не сохраняем пустую галерею
      } // Конец проверки пустоты
      galleryStore[galleryKey] = { items: bucket, meta }; // Сохраняем галерею в хранилище
    } // Конец функции регистрации галереи

    function pickAttachmentClass(type) { // Функция выбора CSS-класса
      if (!type) { // Если тип не указан
        return attachmentTypeClasses.default; // Возвращаем класс по умолчанию
      } // Конец проверки
      return attachmentTypeClasses[type] || attachmentTypeClasses.default; // Возвращаем подходящий класс или запасной
    } // Конец функции

    function buildAttachmentBadge(att, galleryKey, originLabel) { // Функция сборки бейджа вложения
      const type = att?.type || 'file'; // Определяем тип вложения
      const readableType = attachmentTypeLabels[type] || type; // Находим подпись типа
      const href = normalizeAttachmentLink(att); // Получаем ссылку для перехода
      const caption = att?.title || att?.name || att?.doc?.title || att?.link?.title || att?.photo?.text || att?.description || ''; // Подбираем подпись
      const shortCaption = caption ? caption.slice(0, 60) : ''; // Обрезаем подпись
      const className = pickAttachmentClass(type); // Берем класс подсветки
      const text = shortCaption ? `${readableType}: ${shortCaption}` : readableType; // Формируем текст
      const originAttr = originLabel ? ` data-gallery-origin="${originLabel}"` : ''; // Атрибут источника для клика
      if (href) { // Если есть ссылка
        return `<a class="attachment-pill ${className}" href="${href}" data-gallery-key="${galleryKey}"${originAttr} data-gallery-url="${href}" target="_blank" rel="noopener noreferrer">${text}</a>`; // Возвращаем кликабельный бейдж
      } // Конец проверки
      return `<span class="attachment-pill ${className}" data-gallery-key="${galleryKey}"${originAttr}>${text}</span>`; // Возвращаем статичный бейдж
    } // Конец функции

    function renderAttachmentList(list, galleryKey, originLabel) { // Функция рендера списка вложений
      if (!Array.isArray(list) || !list.length) { // Проверяем наличие данных
        return '<span class="text-secondary small">Нет вложений</span>'; // Плейсхолдер при пустом списке
      } // Конец проверки
      const badges = list.map((att) => buildAttachmentBadge(att, galleryKey, originLabel)).join(''); // Собираем бейджи
      return `<div class="attachment-group">${badges}</div>`; // Возвращаем контейнер
    } // Конец функции

    function renderCopyHistory(copyHistory, galleryKey) { // Функция рендера репостов
      if (!Array.isArray(copyHistory) || !copyHistory.length) { // Проверяем наличие репостов
        return ''; // Возвращаем пустую строку
      } // Конец проверки
      const blocks = copyHistory.map((entry) => { // Перебираем репосты
        const source = entry.from_name ? `${entry.from_name} (ID: ${entry.from_id ?? '—'})` : `ID: ${entry.from_id ?? '—'}`; // Формируем подпись источника
        const text = entry.text ? entry.text.slice(0, 120) : 'Без текста'; // Формируем превью текста
        const attachmentsBlock = renderAttachmentList(entry.attachments || [], galleryKey, source); // Формируем вложения репоста
        return `<div class="copy-block"><div class="copy-header">🔁 Репост от ${source}</div><div class="text-secondary small">${text}</div><div class="copy-attachments">${attachmentsBlock}</div></div>`; // Возвращаем карточку репоста
      }); // Конец цикла
      return blocks.join(''); // Возвращаем объединенный HTML
    } // Конец функции

    function buildAttachmentSummary(attachments, copyHistory, galleryKey) { // Формируем бейдж со скрепкой и количеством
      const attachmentsCount = countAttachmentList(attachments); // Считаем вложения сообщения
      const copyCount = countCopyHistoryAttachments(copyHistory); // Считаем вложения в репостах
      const total = attachmentsCount + copyCount; // Складываем общее количество
      if (!total) { // Если вложений нет
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер
      } // Конец проверки пустоты
      const previewLink = findFirstAttachmentLink(attachments) || findFirstCopyHistoryLink(copyHistory); // Ищем ссылку первого вложения
      const className = pickAttachmentClass(total === 1 ? (attachments?.[0]?.type || 'file') : 'file'); // Определяем класс бейджа
      const label = `📎 ${total}`; // Формируем лаконичный текст бейджа со скрепкой и количеством
      if (previewLink) { // Если ссылка найдена
        return `<a class="attachment-pill ${className}" href="${previewLink}" data-gallery-key="${galleryKey}" data-gallery-url="${previewLink}" target="_blank" rel="noopener noreferrer">${label}</a>`; // Возвращаем кликабельный бейдж
      } // Конец проверки ссылки
      return `<span class="attachment-pill ${className}" data-gallery-key="${galleryKey}">${label}</span>`; // Возвращаем статичный бейдж
    } // Конец функции формирования скрепки

    function buildContentCell(attachments, copyHistory, galleryKey) { // Функция сборки ячейки контента
      const hasAttachments = Array.isArray(attachments) && attachments.length > 0; // Проверяем наличие вложений
      const hasCopy = Array.isArray(copyHistory) && copyHistory.length > 0; // Проверяем наличие репостов
      if (!hasAttachments && !hasCopy) { // Если нет данных
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер
      } // Конец проверки
      const summary = buildAttachmentSummary(attachments, copyHistory, galleryKey); // Строим бейдж со скрепкой и количеством
      const copyBlock = hasCopy ? renderCopyHistory(copyHistory, galleryKey) : ''; // Собираем блок репостов
      return `<div class="content-cell">${summary}${copyBlock}</div>`; // Возвращаем объединенную ячейку
    } // Конец функции

    function renderGalleryStrip(galleryData) { // Отрисовываем полосу миниатюр
      if (!galleryData || !Array.isArray(galleryData.items) || galleryData.items.length === 0) { // Проверяем входные данные
        galleryStrip.innerHTML = '<span class="text-secondary small">Вложений нет</span>'; // Показываем плейсхолдер
        return; // Выходим при отсутствии данных
      } // Конец проверки
      const buttons = galleryData.items.map((item, idx) => { // Формируем кнопки для всех вложений
        const typeLabel = attachmentTypeLabels[item.type] || 'Файл'; // Определяем подпись типа
        const activeClass = idx === currentGalleryIndex ? 'active' : ''; // Определяем активную кнопку
        return `<button type="button" class="btn btn-outline-light btn-sm gallery-thumb ${activeClass}" data-gallery-index="${idx}">${idx + 1}. ${typeLabel}</button>`; // Возвращаем HTML кнопки
      }); // Конец сборки кнопок
      galleryStrip.innerHTML = buttons.join(''); // Рисуем полосу миниатюр
    } // Конец функции полосы миниатюр

    function renderGallerySlide(galleryData, index) { // Рисуем текущий слайд галереи
      if (!galleryData || !Array.isArray(galleryData.items) || !galleryData.items.length) { // Проверяем наличие данных
        galleryMedia.innerHTML = '<div class="text-secondary">Вложений нет</div>'; // Показываем плейсхолдер
        galleryCaption.textContent = '—'; // Сбрасываем подпись
        galleryOrigin.textContent = 'Источник неизвестен'; // Сбрасываем источник
        galleryLinks.innerHTML = '—'; // Сбрасываем ссылки
        return; // Выходим
      } // Конец проверки
      const boundedIndex = Math.max(0, Math.min(index, galleryData.items.length - 1)); // Фиксируем индекс в допустимых границах
      currentGalleryIndex = boundedIndex; // Обновляем текущий индекс
      const item = galleryData.items[boundedIndex]; // Получаем выбранный элемент
      const isVideo = isVideoType(item.type); // Проверяем, является ли элемент видео
      const mediaHtml = isVideo ? `<video controls src="${item.url}" class="w-100" preload="metadata"></video>` : `<img src="${item.url}" alt="Вложение" loading="lazy" />`; // Формируем HTML медиа
      galleryMedia.innerHTML = mediaHtml; // Подставляем медиа в модалку
      const caption = item.caption || 'Без описания'; // Подпись элемента
      const origin = item.origin || galleryData.meta.peer || 'Источник неизвестен'; // Источник элемента
      galleryCaption.textContent = caption; // Обновляем подпись
      galleryOrigin.textContent = `${origin} • ${galleryData.meta.peer}`; // Обновляем источник
      const openLink = `<a href="${item.url}" target="_blank" rel="noopener noreferrer">Открыть файл</a>`; // Ссылка на файл
      galleryLinks.innerHTML = `${openLink} · ${galleryData.meta.author}`; // Добавляем ссылку и автора
      renderGalleryStrip(galleryData); // Обновляем полосу миниатюр
    } // Конец функции рендера галереи

    function openGallery(key, targetUrl, targetOrigin) { // Открываем модалку галереи
      const galleryData = galleryStore[key]; // Получаем данные галереи
      if (!galleryData || !galleryData.items.length) { // Проверяем наличие данных
        return; // Выходим при отсутствии вложений
      } // Конец проверки
      currentGalleryKey = key; // Сохраняем активный ключ
      let startIndex = 0; // Стартовый индекс
      if (targetUrl) { // Если указано вложение для старта
        const foundIndex = galleryData.items.findIndex((item) => item.url === targetUrl && (!targetOrigin || item.origin === targetOrigin)); // Ищем совпадение
        if (foundIndex >= 0) { // Если нашли совпадение
          startIndex = foundIndex; // Начинаем с выбранного
        } // Конец проверки совпадения
      } // Конец проверки целевого элемента
      renderGallerySlide(galleryData, startIndex); // Рисуем нужный слайд
      galleryModal.style.display = 'flex'; // Показываем модалку
    } // Конец функции открытия модалки

    function closeGallery() { // Закрываем модалку галереи
      galleryModal.style.display = 'none'; // Скрываем фон
      currentGalleryKey = null; // Сбрасываем ключ
      currentGalleryIndex = 0; // Сбрасываем индекс
    } // Конец функции закрытия

    function stepGallery(delta) { // Переключаем элементы галереи
      if (!currentGalleryKey) { // Проверяем, открыта ли галерея
        return; // Выходим, если модалка закрыта
      } // Конец проверки
      const galleryData = galleryStore[currentGalleryKey]; // Получаем данные активной галереи
      if (!galleryData || !galleryData.items.length) { // Проверяем наличие данных
        return; // Выходим при отсутствии вложений
      } // Конец проверки
      const total = galleryData.items.length; // Количество элементов
      const nextIndex = (currentGalleryIndex + delta + total) % total; // Вычисляем следующий индекс по кругу
      renderGallerySlide(galleryData, nextIndex); // Обновляем отображение
    } // Конец функции переключения

    galleryClose.addEventListener('click', () => closeGallery()); // Обработчик кнопки закрытия
    galleryPrev.addEventListener('click', () => stepGallery(-1)); // Обработчик кнопки назад
    galleryNext.addEventListener('click', () => stepGallery(1)); // Обработчик кнопки вперед
    galleryStrip.addEventListener('click', (evt) => { // Обработчик клика по миниатюрам
      const trigger = evt.target.closest('[data-gallery-index]'); // Ищем кнопку с индексом
      if (!trigger || currentGalleryKey === null) { // Проверяем, есть ли активная галерея
        return; // Выходим при отсутствии
      } // Конец проверки
      const targetIndex = Number(trigger.getAttribute('data-gallery-index')); // Читаем индекс
      const galleryData = galleryStore[currentGalleryKey]; // Берем активную галерею
      if (!galleryData || Number.isNaN(targetIndex)) { // Проверяем данные
        return; // Выходим при ошибке
      } // Конец проверки
      renderGallerySlide(galleryData, targetIndex); // Показываем выбранное вложение
    }); // Конец обработчика клика по миниатюрам
    galleryModal.addEventListener('click', (evt) => { // Закрываем по клику на фон
      if (evt.target === galleryModal) { // Проверяем цель клика
        closeGallery(); // Закрываем модалку
      } // Конец проверки
    }); // Конец обработчика клика по фону
    document.addEventListener('keydown', (evt) => { // Подписка на клавиатуру
      if (galleryModal.style.display === 'flex') { // Проверяем, открыта ли модалка
        if (evt.key === 'Escape') { // Клавиша Esc
          closeGallery(); // Закрываем
        } else if (evt.key === 'ArrowLeft') { // Стрелка влево
          stepGallery(-1); // Назад
        } else if (evt.key === 'ArrowRight') { // Стрелка вправо
          stepGallery(1); // Вперед
        } // Конец проверки клавиш
      } // Конец проверки состояния
    }); // Конец обработчика клавиатуры

    document.addEventListener('click', (evt) => { // Делегируем клики по бейджам вложений
      const trigger = evt.target.closest('[data-gallery-key]'); // Ищем элемент с атрибутом
      if (!trigger) { // Если клик не по бейджу
        return; // Выходим
      } // Конец проверки
      evt.preventDefault(); // Отменяем переход по ссылке
      const key = trigger.getAttribute('data-gallery-key'); // Читаем ключ галереи
      const url = trigger.getAttribute('data-gallery-url'); // Читаем ссылку на файл
      const originLabel = trigger.getAttribute('data-gallery-origin'); // Читаем источник
      openGallery(key, url, originLabel); // Открываем модалку
    }); // Конец делегирования

    function switchToMessages() { // Функция показа вкладки сообщений
      messagesSection.classList.remove('d-none'); // Убираем скрытие секции сообщений
      messagesSection.classList.add('d-block'); // Добавляем показ секции сообщений
      serviceSection.classList.add('d-none'); // Скрываем секцию сервисных логов
      serviceSection.classList.remove('d-block'); // Убираем класс показа сервисных логов
      messagesTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сообщений
      messagesTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки
      serviceTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с сервисной вкладки
      serviceTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сервисной вкладки
    } // Конец функции переключения на сообщения

    function switchToService() { // Функция показа вкладки сервисных логов
      serviceSection.classList.remove('d-none'); // Убираем скрытие секции сервисных логов
      serviceSection.classList.add('d-block'); // Добавляем показ секции сервисных логов
      messagesSection.classList.add('d-none'); // Скрываем секцию сообщений
      messagesSection.classList.remove('d-block'); // Убираем класс показа секции сообщений
      serviceTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сервисных логов
      serviceTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки сервисной вкладки
      messagesTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с вкладки сообщений
      messagesTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сообщений
    } // Конец функции переключения на сервисные логи

    function handleHashNavigation() { // Обрабатываем якорь в адресной строке
      const wantsService = window.location.hash.includes('service-alerts'); // Проверяем, нужен ли раздел сервисных логов
      if (wantsService) { // Если нужно открыть сервисные логи
        serviceTypeSelect.value = 'important'; // Ставим фильтр «Важные» по умолчанию
        serviceOffset = 0; // Сбрасываем смещение пагинации
        switchToService(); // Переключаемся на вкладку сервисных логов
        refreshServiceLogs(); // Обновляем таблицу с новым фильтром
      } else { // Если якоря нет или он другой
        switchToMessages(); // Возвращаемся на вкладку логов сообщений
      } // Конец проверки якоря
    } // Конец функции обработки якоря

    function renderPeers(peers) { // Функция отрисовки списка чатов
      peerFilter.innerHTML = '<option value="">Все чаты</option>'; // Сбрасываем селектор
      (peers || []).forEach((peer) => { // Перебираем чаты
        if (!peer || !Number.isFinite(peer.id)) return; // Пропускаем некорректные записи
        const option = document.createElement('option'); // Создаем опцию
        option.value = peer.id; // Значение опции
        const label = peer.title ? `${peer.title} (ID: ${peer.id})` : peer.id; // Подпись опции
        option.textContent = label; // Текст опции
        peerFilter.appendChild(option); // Добавляем опцию
      }); // Конец цикла
      if (initialPeerId !== null) { // Если стартовый фильтр задан
        peerFilter.value = initialPeerId; // Устанавливаем значение
      } // Конец условия
    } // Конец функции отрисовки чатов

    function renderLogs(logs) { // Функция отрисовки таблицы логов
      logsBody.innerHTML = ''; // Очищаем тело
      resetGalleryStorePreserveActive(); // Очищаем хранилище, сохраняя открытую галерею
      galleryCounter = 0; // Обнуляем счетчик ключей
      if (!logs.length) { // Если массив пустой
        logsBody.innerHTML = '<tr><td colspan="10" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Завершаем функцию
      } // Конец проверки пустоты
      logs.forEach((log) => { // Перебираем логи
        const row = document.createElement('tr'); // Создаем строку
        const galleryKey = `log-${log.id ?? 'local'}-${galleryCounter++}`; // Формируем ключ галереи для записи
        const normalizedAttachments = extractAttachments(log); // Нормализуем вложения из лога или payload
        const normalizedCopyHistory = extractCopyHistory(log); // Нормализуем copy_history из лога или payload
        registerGallery({ ...log, attachments: normalizedAttachments, copy_history: normalizedCopyHistory }, galleryKey); // Регистрируем вложения для модалки
        const contentCell = buildContentCell(normalizedAttachments, normalizedCopyHistory, galleryKey); // Формируем ячейку контента
        const botBadge = log.is_bot ? 'Да' : 'Нет'; // Флаг бота
        const peerTitle = log.peer_title || 'Чат без названия'; // Подпись чата
        const peerLabel = log.peer_id
          ? `<a href="/chat/${log.peer_id}" target="_blank" class="text-decoration-none text-light d-inline-flex align-items-center gap-2">${buildAvatarLabel(peerTitle, log.peer_avatar)}</a>`
          : '<span class="text-secondary">—</span>'; // Ссылка на чат или плейсхолдер
        const authorTitle = log.from_name || 'Неизвестный отправитель'; // Подпись отправителя
        const authorLabel = log.from_id
          ? `<a href="/user/${log.from_id}" target="_blank" class="text-decoration-none text-light d-inline-flex align-items-center gap-2">${buildAvatarLabel(authorTitle, log.from_avatar)}</a>`
          : '<span class="text-secondary">—</span>'; // Ссылка на пользователя или плейсхолдер
        const createdAt = formatDateTime(log.created_at); // Преобразуем время в локальный формат
        const replyCell = buildReplyPreview(log.reply, log.peer_id); // Готовим ячейку превью исходного сообщения
        row.innerHTML = `<td>${createdAt}</td><td>${peerLabel}</td><td>${authorLabel}</td><td>${botBadge}</td><td>${replyCell}</td><td>${contentCell}</td><td>${log.text ?? ''}</td><td>${log.message_id ?? '—'}</td><td>${log.id ?? '—'}</td><td><button type="button" class="btn btn-sm btn-outline-danger delete-log-btn" data-log-id="${log.id}">Удалить</button></td>`; // Заполняем ячейки и кнопку удаления
        logsBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции отрисовки

    async function deleteLog(recordId) { // Функция удаления одной записи
      const confirmed = window.confirm('Удалить выбранную строку лога сообщений? Действие необратимо.'); // Подтверждаем действие
      if (!confirmed) { // Если пользователь отказался
        return; // Прерываем удаление
      } // Конец проверки согласия
      try { // Пытаемся выполнить запрос
        const response = await fetch(`/api/logs/${recordId}`, { method: 'DELETE' }); // Отправляем запрос удаления
        if (!response.ok) { // Проверяем код ответа
          throw new Error('Удаление завершилось ошибкой'); // Бросаем исключение при проблеме
        } // Конец проверки кода ответа
        await refreshLogs(); // Перерисовываем таблицу после удаления
      } catch (err) { // Обработка ошибки
        console.error('Не удалось удалить запись лога', err); // Логируем проблему
      } // Конец обработки
    } // Конец функции удаления записи

    function renderServiceLogs(logs) { // Функция отрисовки сервисных оповещений
      serviceBody.innerHTML = ''; // Очищаем тело таблицы
      if (!logs.length) { // Проверяем наличие данных
        serviceBody.innerHTML = '<tr><td colspan="5" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Завершаем функцию
      } // Конец проверки
      logs.forEach((log) => { // Перебираем оповещения
        const row = document.createElement('tr'); // Создаем строку
        const type = log.event_type || 'info'; // Определяем тип события
        const badgeClass = `service-pill ${type}`; // Готовим класс пилюли
        const dotClass = `service-dot ${type}`; // Готовим класс точки
        const createdAt = formatDateTime(log.created_at); // Форматируем время сервисного события
        row.innerHTML = `<td>${createdAt}</td><td><span class="${badgeClass}"><span class="${dotClass}"></span>${type}</span></td><td>${log.status_code ?? '—'}</td><td>${log.description ?? '—'}</td><td>${log.message ?? ''}</td>`; // Заполняем строку
        serviceBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции отрисовки сервисных логов

    async function fetchLogs(params) { // Функция запроса логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем объект параметров
      const response = await fetch(`/api/logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data.items || []; // Возвращаем список логов
    } // Конец функции запроса

    async function fetchServiceLogs(params) { // Функция запроса сервисных логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем параметры запроса
      const response = await fetch(`/api/service-logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data; // Возвращаем полный ответ
    } // Конец функции запроса сервисных логов

    async function refreshLogs() { // Функция обновления таблицы
      try { // Блок попытки
        const params = {}; // Объект параметров запроса
        if (peerFilter.value) { // Если выбран чат
          params.peer_id = peerFilter.value; // Добавляем фильтр чата
        } // Конец условия
        if (limitInput.value) { // Если задан лимит
          params.limit = limitInput.value; // Добавляем лимит
        } // Конец условия
        const logs = await fetchLogs(params); // Получаем логи с сервера
        renderLogs(logs); // Отрисовываем таблицу
      } catch (err) { // Обработка ошибок
        console.error('Не удалось обновить логи', err); // Пишем в консоль
      } // Конец обработки
    } // Конец функции обновления

    async function clearLogs() { // Функция полной очистки логов сообщений
      const confirmed = window.confirm('Очистить все логи сообщений? Это действие удалит записи без возможности восстановления.'); // Спрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отказ
        return; // Прерываем выполнение при отмене
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/logs/clear', { method: 'POST' }); // Отправляем POST-запрос на очистку логов сообщений
        await refreshLogs(); // Перерисовываем таблицу после очистки
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить логи сообщений', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки логов сообщений

    async function refreshServiceLogs() { // Функция обновления сервисных логов
      try { // Блок попытки
        const params = {}; // Готовим параметры
        const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
        if (serviceTypeSelect.value) { // Если выбран тип
          params.event_type = serviceTypeSelect.value; // Добавляем тип
        } // Конец условия
        params.limit = limit; // Добавляем лимит
        params.offset = serviceOffset; // Добавляем смещение
        const result = await fetchServiceLogs(params); // Получаем данные
        serviceTotal = Number(result.total || 0); // Сохраняем количество
        renderServiceLogs(result.items || []); // Отрисовываем таблицу
        const end = Math.min(serviceOffset + limit, serviceTotal || 0); // Считаем конец диапазона
        servicePrevBtn.disabled = serviceOffset === 0; // Блокируем кнопку назад при нуле
        serviceNextBtn.disabled = serviceOffset + limit >= serviceTotal; // Блокируем кнопку вперед при достижении конца
        servicePageLabel.textContent = serviceTotal ? `Показано ${end} из ${serviceTotal}` : 'Нет данных'; // Обновляем подпись
      } catch (err) { // Обработка ошибок
        console.error('Не удалось обновить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции обновления сервисных логов

    async function clearServiceLogs() { // Функция очистки сервисных логов
      const confirmed = window.confirm('Очистить все сервисные логи? Это действие нельзя отменить.'); // Запрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отмену
        return; // Прерываем выполнение при отказе
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/service-logs/clear', { method: 'POST' }); // Отправляем POST очистки
        serviceOffset = 0; // Сбрасываем смещение
        await refreshServiceLogs(); // Перерисовываем таблицу
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки

    filtersForm.addEventListener('submit', (event) => { // Обработчик отправки формы
      event.preventDefault(); // Отменяем стандартное поведение
      refreshLogs(); // Перезапрашиваем логи
    }); // Конец обработчика формы

    logsBody.addEventListener('click', (event) => { // Делегированный обработчик кликов по таблице логов
      const deleteButton = event.target.closest('.delete-log-btn'); // Ищем кнопку удаления
      if (!deleteButton) { // Если клик не по кнопке удаления
        return; // Прерываем обработку
      } // Конец проверки назначения клика
      const recordId = deleteButton.dataset.logId; // Берем ID записи из data-атрибута
      if (!recordId) { // Если ID не найден
        return; // Завершаем без вызова API
      } // Конец проверки наличия ID
      deleteLog(recordId); // Запускаем удаление выбранной строки
    }); // Конец делегированного обработчика

    refreshBtn.addEventListener('click', () => { // Обработчик кнопки обновления
      refreshLogs(); // Перезапрашиваем логи
    }); // Конец обработчика кнопки

    clearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки логов сообщений
      event.preventDefault(); // Блокируем стандартное действие кнопки
      clearLogs(); // Запускаем очистку логов сообщений
    }); // Конец обработчика кнопки очистки

    serviceRefreshBtn.addEventListener('click', (event) => { // Обработчик обновления сервисных логов
      event.preventDefault(); // Отменяем действие кнопки
      refreshServiceLogs(); // Перезапрашиваем сервисные логи
    }); // Конец обработчика обновления

    serviceClearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки
      event.preventDefault(); // Отменяем действие кнопки
      clearServiceLogs(); // Запускаем очистку
    }); // Конец обработчика очистки

    serviceTypeSelect.addEventListener('change', () => { // Обработчик смены типа
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs(); // Перерисовываем данные
    }); // Конец обработчика смены типа

    serviceLimitInput.addEventListener('change', () => { // Обработчик смены лимита
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика смены лимита

    servicePrevBtn.addEventListener('click', () => { // Обработчик кнопки назад
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset = Math.max(0, serviceOffset - limit); // Уменьшаем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика кнопки назад

    serviceNextBtn.addEventListener('click', () => { // Обработчик кнопки вперед
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset += limit; // Увеличиваем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика кнопки вперед

    messagesTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сообщений
      switchToMessages(); // Показываем секцию сообщений
    }); // Конец обработчика вкладки сообщений

    serviceTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сервисных логов
      switchToService(); // Показываем секцию сервисных логов
      refreshServiceLogs(); // Перезапрашиваем сервисные логи при показе
    }); // Конец обработчика вкладки сервисных логов

    window.addEventListener('hashchange', () => { // Подписываемся на изменения якоря в адресе
      handleHashNavigation(); // Переключаем вкладки в зависимости от нового якоря
    }); // Конец обработчика изменения якоря

    limitInput.value = initialLimit; // Устанавливаем стартовый лимит
    renderPeers(initialPeers || []); // Отрисовываем селектор чатов
    renderLogs(initialLogs || []); // Отрисовываем стартовые логи
    serviceTotal = (initialServiceLogs || []).length; // Запоминаем количество стартовых сервисных логов
    servicePageLabel.textContent = serviceTotal ? `Показано ${Math.min(serviceTotal, Number(serviceLimitInput.value) || 50)} из ${serviceTotal}` : 'Нет данных'; // Показываем подпись пагинации
    renderServiceLogs(initialServiceLogs || []); // Отрисовываем стартовые сервисные логи
    handleHashNavigation(); // Выбираем нужную вкладку с учетом якоря
  </script> <!-- Конец скрипта -->
</body> <!-- Конец тела -->
</html> <!-- Конец документа -->
