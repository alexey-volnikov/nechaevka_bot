<!doctype html> <!-- Объявляем тип документа -->
<html lang="ru"> <!-- Устанавливаем язык страницы -->
<head> <!-- Начало шапки -->
  <meta charset="UTF-8" /> <!-- Кодировка -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- Адаптивность -->
  <title>Полные логи сообщений</title> <!-- Заголовок вкладки -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" /> <!-- Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com" /> <!-- Предзагрузка шрифтов -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> <!-- Кросс-домен для шрифтов -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" /> <!-- Шрифт Inter -->
  <style> /* Начало пользовательских стилей */
    body { background: #0f172a; color: #e2e8f0; font-family: "Inter", system-ui, -apple-system, sans-serif; } /* Фон и текст */
    .glass { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 18px; backdrop-filter: blur(10px); } /* Стеклянный стиль */
    .badge-soft { background: rgba(99, 102, 241, 0.15); color: #c7d2fe; border: 1px solid rgba(99, 102, 241, 0.35); } /* Мягкий бейдж */
    .table > :not(caption) > * > * { background-color: transparent; color: #e2e8f0; } /* Прозрачные ячейки */
    .table-striped > tbody > tr:nth-of-type(odd) > * { background: rgba(255, 255, 255, 0.03); } /* Полосатость */
    .shadow-soft { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25); } /* Мягкая тень */
    .service-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 12px; font-size: 12px; } /* Пилюля статуса */
    .service-pill.info { background: rgba(56, 189, 248, 0.2); color: #bae6fd; border: 1px solid rgba(56, 189, 248, 0.5); } /* Цвет инфо */
    .service-pill.warning { background: rgba(234, 179, 8, 0.2); color: #fef08a; border: 1px solid rgba(234, 179, 8, 0.5); } /* Цвет предупреждения */
    .service-pill.error { background: rgba(248, 113, 113, 0.2); color: #fecdd3; border: 1px solid rgba(248, 113, 113, 0.5); } /* Цвет ошибки */
    .service-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; } /* Точка индикации */
    .service-dot.info { background: #38bdf8; } /* Цвет точки инфо */
    .service-dot.warning { background: #fbbf24; } /* Цвет точки предупреждения */
    .service-dot.error { background: #f87171; } /* Цвет точки ошибки */
    .avatar-inline { width: 1.6em; height: 1.6em; border-radius: 999px; object-fit: cover; flex-shrink: 0; } /* Класс компактной аватарки */
  </style> <!-- Конец стилей -->
</head> <!-- Конец шапки -->
<body class="pb-5"> <!-- Тело страницы -->
  <div class="container py-4"> <!-- Контейнер -->
    <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-3 mb-4"> <!-- Заголовок страницы -->
      <div> <!-- Левая часть -->
        <div class="d-inline-flex align-items-center gap-2 mb-2"> <!-- Бейдж -->
          <span class="badge-soft badge rounded-pill"> <!-- Обертка бейджа -->
            Полные логи <!-- Подпись -->
          </span> <!-- Конец бейджа -->
        </div> <!-- Конец блока бейджа -->
        <h1 class="fw-bold mb-1">Все сообщения</h1> <!-- Заголовок -->
        <p class="text-secondary mb-0">До 1000 последних записей с фильтрацией по чатам.</p> <!-- Подзаголовок -->
      </div> <!-- Конец левой части -->
      <div class="d-flex flex-wrap gap-2"> <!-- Правая часть с кнопками -->
        <a href="/" class="btn btn-outline-light">Вернуться к дашборду</a> <!-- Кнопка назад -->
        <button id="refresh-btn" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
        <button id="clear-btn" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки логов сообщений -->
      </div> <!-- Конец правой части -->
    </div> <!-- Конец заголовка страницы -->

    <ul class="nav nav-pills mb-4 gap-2 flex-wrap"> <!-- Панель вкладок -->
      <li class="nav-item"> <!-- Пункт вкладки сообщений -->
        <button id="messages-tab-btn" class="nav-link active text-light bg-primary" type="button">Логи сообщений</button> <!-- Кнопка вкладки сообщений -->
      </li> <!-- Конец пункта вкладки сообщений -->
      <li class="nav-item"> <!-- Пункт вкладки сервисных логов -->
        <button id="service-tab-btn" class="nav-link text-light bg-dark border border-secondary" type="button">Сервисные логи</button> <!-- Кнопка вкладки сервисных логов -->
      </li> <!-- Конец пункта вкладки сервисных логов -->
    </ul> <!-- Конец панели вкладок -->

    <div id="messages-section" class="d-block"> <!-- Секция логов сообщений -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров -->
        <form id="filters-form" class="row g-3 align-items-end"> <!-- Форма фильтров -->
          <div class="col-12 col-md-5"> <!-- Колонка селектора чатов -->
            <label class="form-label text-secondary small" for="peer-filter">Фильтр по peer_id</label> <!-- Подпись -->
            <select id="peer-filter" name="peer_id" class="form-select bg-dark text-light border-secondary"> <!-- Селектор -->
              <option value="">Все чаты</option> <!-- Опция по умолчанию -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-3"> <!-- Колонка лимита -->
            <label class="form-label text-secondary small" for="limit-input">Лимит записей (до 1000)</label> <!-- Подпись -->
            <input type="number" id="limit-input" name="limit" class="form-control bg-dark text-light border-secondary" min="1" max="1000" /> <!-- Поле лимита -->
          </div> <!-- Конец колонки лимита -->
          <div class="col-12 col-md-4 d-flex gap-2"> <!-- Колонка кнопок -->
            <button type="submit" class="btn btn-primary flex-grow-1">Применить фильтр</button> <!-- Кнопка отправки -->
            <a href="/logs/full" class="btn btn-outline-light">Сбросить</a> <!-- Кнопка сброса -->
          </div> <!-- Конец колонки кнопок -->
        </form> <!-- Конец формы -->
      </div> <!-- Конец блока фильтров -->

      <div class="glass shadow-soft p-4"> <!-- Блок таблицы -->
        <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок таблицы -->
          <div> <!-- Левая часть -->
            <div class="card-title mb-1">Логи сообщений</div> <!-- Название -->
            <div class="text-secondary small">Содержимое базы с именами, чатами и вложениями.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center gap-2"> <!-- Контейнер бейджей -->
            <span class="badge-soft badge rounded-pill" id="timezone-hint" title="">Локальное время</span> <!-- Бейдж с подсказкой о таймзоне -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
          </div> <!-- Конец контейнера бейджей -->
        </div> <!-- Конец заголовка таблицы -->
        <div class="table-responsive"> <!-- Обертка таблицы -->
          <table class="table table-striped align-middle mb-0"> <!-- Таблица -->
            <thead class="text-secondary"> <!-- Шапка -->
              <tr> <!-- Строка заголовков -->
                <th>Время</th> <!-- Колонка времени -->
                <th>Чат</th> <!-- Колонка чата -->
                <th>Отправитель</th> <!-- Колонка автора -->
                <th>Бот?</th> <!-- Колонка бота -->
                <th>Ответ</th> <!-- Колонка ответа -->
                <th>Вложения</th> <!-- Колонка вложений -->
                <th>Текст</th> <!-- Колонка текста -->
                <th>ID VK</th> <!-- Колонка ID сообщения во VK -->
                <th>Запись</th> <!-- Колонка ID в базе -->
                <th>Действия</th> <!-- Колонка действий -->
              </tr> <!-- Конец строки заголовков -->
            </thead> <!-- Конец шапки -->
            <tbody id="logs-body"> <!-- Тело таблицы -->
              <tr> <!-- Плейсхолдер -->
                <td colspan="10" class="text-secondary">Нет данных</td> <!-- Текст плейсхолдера -->
              </tr> <!-- Конец плейсхолдера -->
            </tbody> <!-- Конец тела таблицы -->
          </table> <!-- Конец таблицы -->
        </div> <!-- Конец обертки таблицы -->
      </div> <!-- Конец блока таблицы -->
    </div> <!-- Конец секции логов сообщений -->

    <div id="service-section" class="d-none"> <!-- Секция сервисных логов -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров сервисных логов -->
        <form id="service-filters" class="row g-3 align-items-end"> <!-- Форма фильтра сервисных логов -->
          <div class="col-12 col-md-4"> <!-- Колонка типа события -->
            <label class="form-label text-secondary small" for="service-type">Тип оповещения</label> <!-- Подпись -->
            <select id="service-type" class="form-select bg-dark text-light border-secondary"> <!-- Селектор типа -->
              <option value="">Все</option> <!-- Опция все -->
              <option value="important">Важные (warning+error)</option> <!-- Опция важных -->
              <option value="error">Только ошибки</option> <!-- Опция ошибок -->
              <option value="warning">Предупреждения</option> <!-- Опция предупреждений -->
              <option value="info">Информационные</option> <!-- Опция инфо -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-3"> <!-- Колонка лимита -->
            <label class="form-label text-secondary small" for="service-limit">Лимит строк</label> <!-- Подпись -->
            <input type="number" id="service-limit" class="form-control bg-dark text-light border-secondary" min="1" max="200" value="50" /> <!-- Поле лимита -->
          </div> <!-- Конец колонки лимита -->
          <div class="col-12 col-md-5"> <!-- Колонка пагинации -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер кнопок -->
              <button id="service-prev" class="btn btn-outline-light flex-grow-1" type="button">Назад</button> <!-- Кнопка назад -->
              <button id="service-next" class="btn btn-outline-light flex-grow-1" type="button">Вперед</button> <!-- Кнопка вперед -->
              <span id="service-page" class="text-secondary small">—</span> <!-- Подпись страницы -->
            </div> <!-- Конец контейнера -->
          </div> <!-- Конец колонки -->
        </form> <!-- Конец формы фильтра -->
      </div> <!-- Конец блока фильтров сервисных логов -->

      <div id="service-alerts" class="glass shadow-soft p-4"> <!-- Блок сервисных оповещений -->
        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-3"> <!-- Заголовок блока -->
          <div> <!-- Левая часть заголовка -->
            <div class="card-title mb-1">Сервисные оповещения</div> <!-- Заголовок текста -->
            <div class="text-secondary small">Ошибки, предупреждения и информирование о работе сервиса.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center flex-wrap gap-2"> <!-- Правая часть с элементами -->
            <span class="badge-soft badge rounded-pill" id="service-timezone-hint" title="">Локальное время</span> <!-- Бейдж подсказки таймзоны -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
            <div class="d-flex flex-wrap gap-2"> <!-- Группа кнопок -->
              <button id="service-refresh" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
              <button id="service-clear" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки -->
            </div> <!-- Конец группы кнопок -->
          </div> <!-- Конец правой части -->
        </div> <!-- Конец заголовка блока -->
        <div class="table-responsive"> <!-- Обертка таблицы сервисных логов -->
          <table class="table table-striped align-middle mb-0"> <!-- Таблица сервисных логов -->
            <thead class="text-secondary"> <!-- Заголовок таблицы -->
              <tr> <!-- Строка заголовка -->
                <th>Время</th> <!-- Колонка времени -->
                <th>Тип</th> <!-- Колонка типа -->
                <th>Код</th> <!-- Колонка кода -->
                <th>Пояснение</th> <!-- Колонка пояснения -->
                <th>Сообщение</th> <!-- Колонка текста -->
              </tr> <!-- Конец строки -->
            </thead> <!-- Конец шапки -->
            <tbody id="service-logs-body"> <!-- Тело таблицы сервисных логов -->
              <tr> <!-- Плейсхолдер -->
                <td colspan="5" class="text-secondary">Нет данных</td> <!-- Текст плейсхолдера -->
              </tr> <!-- Конец плейсхолдера -->
            </tbody> <!-- Конец тела -->
          </table> <!-- Конец таблицы -->
        </div> <!-- Конец обертки -->
      </div> <!-- Конец блока сервисных оповещений -->
    </div> <!-- Конец секции сервисных логов -->
  </div> <!-- Конец контейнера -->

  <script> // Начало скрипта
    const initialLogs = {{ initial_logs|tojson }}; // Стартовые логи из шаблона
    const initialPeers = {{ initial_peers|tojson }}; // Стартовый список чатов
    const initialPeerId = {{ initial_peer_id|tojson }}; // Стартовый peer_id
    const initialLimit = {{ initial_limit|tojson }}; // Стартовый лимит
    const initialServiceLogs = {{ initial_service_logs|tojson }}; // Стартовые сервисные логи

    const logsBody = document.getElementById('logs-body'); // Тело таблицы логов
    const peerFilter = document.getElementById('peer-filter'); // Селектор чатов
    const limitInput = document.getElementById('limit-input'); // Поле лимита
    const refreshBtn = document.getElementById('refresh-btn'); // Кнопка обновления
    const clearBtn = document.getElementById('clear-btn'); // Кнопка очистки логов сообщений
    const filtersForm = document.getElementById('filters-form'); // Форма фильтров
    const serviceBody = document.getElementById('service-logs-body'); // Тело таблицы сервисных логов
    const serviceTypeSelect = document.getElementById('service-type'); // Селектор типа сервисных событий
    const serviceLimitInput = document.getElementById('service-limit'); // Поле лимита сервисных событий
    const servicePrevBtn = document.getElementById('service-prev'); // Кнопка назад
    const serviceNextBtn = document.getElementById('service-next'); // Кнопка вперед
    const servicePageLabel = document.getElementById('service-page'); // Текст пагинации
    const serviceRefreshBtn = document.getElementById('service-refresh'); // Кнопка обновления сервисных логов
    const serviceClearBtn = document.getElementById('service-clear'); // Кнопка очистки сервисных логов
    const messagesSection = document.getElementById('messages-section'); // Секция логов сообщений
    const serviceSection = document.getElementById('service-section'); // Секция сервисных логов
    const messagesTabBtn = document.getElementById('messages-tab-btn'); // Кнопка вкладки сообщений
    const serviceTabBtn = document.getElementById('service-tab-btn'); // Кнопка вкладки сервисных логов
    let serviceOffset = 0; // Текущее смещение
    let serviceTotal = 0; // Общее количество сервисных событий

    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions(); // Читаем параметры локальной таймзоны
    const timezoneOffsetMinutes = new Date().getTimezoneOffset(); // Получаем смещение в минутах относительно UTC
    const timezoneOffsetSign = timezoneOffsetMinutes <= 0 ? '+' : '-'; // Определяем знак смещения
    const timezoneOffsetHours = String(Math.floor(Math.abs(timezoneOffsetMinutes) / 60)).padStart(2, '0'); // Вычисляем часы смещения
    const timezoneOffsetRestMinutes = String(Math.abs(timezoneOffsetMinutes) % 60).padStart(2, '0'); // Вычисляем минуты смещения
    const timezoneLabel = `UTC${timezoneOffsetSign}${timezoneOffsetHours}:${timezoneOffsetRestMinutes} (${timezoneInfo.timeZone || 'локальное время'})`; // Формируем строку подсказки
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: timezoneInfo.timeZone, timeZoneName: 'short' }); // Настраиваем форматер локального времени

    document.getElementById('timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сообщений
    document.getElementById('service-timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сервисных логов

    function formatDateTime(value) { // Функция форматирования даты в локальное время
      const parsed = value ? new Date(value) : null; // Парсим строку даты
      return parsed && !Number.isNaN(parsed.valueOf()) ? timeFormatter.format(parsed) : '—'; // Возвращаем отформатированное значение или тире
    } // Конец функции форматирования

    function buildAvatarLabel(label, avatarUrl) { // Функция построения подписи с аватаркой
      const safeLabel = label || '—'; // Определяем подпись, если значения нет
      if (avatarUrl) { // Если есть ссылка на аватар
        return `<span class="d-inline-flex align-items-center gap-2"><img src="${avatarUrl}" alt="Аватар" class="avatar-inline" loading="lazy" /> <span>${safeLabel}</span></span>`; // Возвращаем подпись с картинкой
      } // Конец проверки аватара
      return safeLabel; // Если аватар отсутствует, возвращаем только текст
    } // Конец функции построения подписи

    function buildReplyPreview(reply, peerId) { // Функция сборки ячейки ответа
      if (!reply || (!reply.id && !reply.text && !reply.from_id)) { // Проверяем наличие полезных данных
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер при отсутствии ответа
      } // Конец проверки наличия ответа
      const replyId = reply.id ?? '—'; // Определяем ID исходного сообщения
      const replyText = reply.text ? reply.text.slice(0, 120) : 'Без текста'; // Готовим превью текста
      const replyAuthorLabel = reply.from_name ? `${reply.from_name} (ID: ${reply.from_id ?? '—'})` : reply.from_id ? `ID: ${reply.from_id}` : 'Автор неизвестен'; // Формируем подпись автора ответа
      const replyAuthorCell = buildAvatarLabel(replyAuthorLabel, reply.from_avatar); // Готовим подпись автора с аватаркой
      const replyLink = reply.id && peerId ? `<a href="https://vk.com/im?sel=${peerId}&msgid=${reply.id}" target="_blank" rel="noopener noreferrer">#${reply.id}</a>` : `#${replyId}`; // Собираем ссылку на исходное сообщение
      const replyAttachmentsCount = Array.isArray(reply.attachments) ? reply.attachments.length : 0; // Считаем вложения исходного сообщения
      const replyAttachmentsLabel = replyAttachmentsCount ? `${replyAttachmentsCount} влож.` : 'Без вложений'; // Формируем подпись вложений
      return `<div class="d-flex flex-column gap-1"><div class="d-flex align-items-center gap-2">${replyLink}<span class="text-secondary small">${replyAttachmentsLabel}</span></div><div class="text-secondary small">${replyText}</div><div class="text-secondary small">${replyAuthorCell}</div></div>`; // Возвращаем HTML ячейки
    } // Конец функции сборки ответа

    function switchToMessages() { // Функция показа вкладки сообщений
      messagesSection.classList.remove('d-none'); // Убираем скрытие секции сообщений
      messagesSection.classList.add('d-block'); // Добавляем показ секции сообщений
      serviceSection.classList.add('d-none'); // Скрываем секцию сервисных логов
      serviceSection.classList.remove('d-block'); // Убираем класс показа сервисных логов
      messagesTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сообщений
      messagesTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки
      serviceTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с сервисной вкладки
      serviceTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сервисной вкладки
    } // Конец функции переключения на сообщения

    function switchToService() { // Функция показа вкладки сервисных логов
      serviceSection.classList.remove('d-none'); // Убираем скрытие секции сервисных логов
      serviceSection.classList.add('d-block'); // Добавляем показ секции сервисных логов
      messagesSection.classList.add('d-none'); // Скрываем секцию сообщений
      messagesSection.classList.remove('d-block'); // Убираем класс показа секции сообщений
      serviceTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сервисных логов
      serviceTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки сервисной вкладки
      messagesTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с вкладки сообщений
      messagesTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сообщений
    } // Конец функции переключения на сервисные логи

    function renderPeers(peers) { // Функция отрисовки списка чатов
      peerFilter.innerHTML = '<option value="">Все чаты</option>'; // Сбрасываем селектор
      (peers || []).forEach((peer) => { // Перебираем чаты
        if (!peer || !Number.isFinite(peer.id)) return; // Пропускаем некорректные записи
        const option = document.createElement('option'); // Создаем опцию
        option.value = peer.id; // Значение опции
        const label = peer.title ? `${peer.title} (ID: ${peer.id})` : peer.id; // Подпись опции
        option.textContent = label; // Текст опции
        peerFilter.appendChild(option); // Добавляем опцию
      }); // Конец цикла
      if (initialPeerId !== null) { // Если стартовый фильтр задан
        peerFilter.value = initialPeerId; // Устанавливаем значение
      } // Конец условия
    } // Конец функции отрисовки чатов

    function renderLogs(logs) { // Функция отрисовки таблицы логов
      logsBody.innerHTML = ''; // Очищаем тело
      if (!logs.length) { // Если массив пустой
        logsBody.innerHTML = '<tr><td colspan="10" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Завершаем функцию
      } // Конец проверки пустоты
      logs.forEach((log) => { // Перебираем логи
        const row = document.createElement('tr'); // Создаем строку
        const attachments = Array.isArray(log.attachments) ? log.attachments.length : 0; // Считаем вложения
        const botBadge = log.is_bot ? 'Да' : 'Нет'; // Флаг бота
        const peerLabel = log.peer_title ? `${log.peer_title} (ID: ${log.peer_id ?? '—'})` : `${log.peer_id ?? '—'}`; // Подпись чата
        const authorLabel = log.from_name ? `${log.from_name} (ID: ${log.from_id ?? '—'})` : `${log.from_id ?? '—'}`; // Подпись автора
        const createdAt = formatDateTime(log.created_at); // Преобразуем время в локальный формат
        const replyCell = buildReplyPreview(log.reply, log.peer_id); // Готовим ячейку превью исходного сообщения
        row.innerHTML = `<td>${createdAt}</td><td>${peerLabel}</td><td>${authorLabel}</td><td>${botBadge}</td><td>${replyCell}</td><td>${attachments}</td><td>${log.text ?? ''}</td><td>${log.message_id ?? '—'}</td><td>${log.id ?? '—'}</td><td><button type="button" class="btn btn-sm btn-outline-danger delete-log-btn" data-log-id="${log.id}">Удалить</button></td>`; // Заполняем ячейки и кнопку удаления
        logsBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции отрисовки

    async function deleteLog(recordId) { // Функция удаления одной записи
      const confirmed = window.confirm('Удалить выбранную строку лога сообщений? Действие необратимо.'); // Подтверждаем действие
      if (!confirmed) { // Если пользователь отказался
        return; // Прерываем удаление
      } // Конец проверки согласия
      try { // Пытаемся выполнить запрос
        const response = await fetch(`/api/logs/${recordId}`, { method: 'DELETE' }); // Отправляем запрос удаления
        if (!response.ok) { // Проверяем код ответа
          throw new Error('Удаление завершилось ошибкой'); // Бросаем исключение при проблеме
        } // Конец проверки кода ответа
        await refreshLogs(); // Перерисовываем таблицу после удаления
      } catch (err) { // Обработка ошибки
        console.error('Не удалось удалить запись лога', err); // Логируем проблему
      } // Конец обработки
    } // Конец функции удаления записи

    function renderServiceLogs(logs) { // Функция отрисовки сервисных оповещений
      serviceBody.innerHTML = ''; // Очищаем тело таблицы
      if (!logs.length) { // Проверяем наличие данных
        serviceBody.innerHTML = '<tr><td colspan="5" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Завершаем функцию
      } // Конец проверки
      logs.forEach((log) => { // Перебираем оповещения
        const row = document.createElement('tr'); // Создаем строку
        const type = log.event_type || 'info'; // Определяем тип события
        const badgeClass = `service-pill ${type}`; // Готовим класс пилюли
        const dotClass = `service-dot ${type}`; // Готовим класс точки
        const createdAt = formatDateTime(log.created_at); // Форматируем время сервисного события
        row.innerHTML = `<td>${createdAt}</td><td><span class="${badgeClass}"><span class="${dotClass}"></span>${type}</span></td><td>${log.status_code ?? '—'}</td><td>${log.description ?? '—'}</td><td>${log.message ?? ''}</td>`; // Заполняем строку
        serviceBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции отрисовки сервисных логов

    async function fetchLogs(params) { // Функция запроса логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем объект параметров
      const response = await fetch(`/api/logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data.items || []; // Возвращаем список логов
    } // Конец функции запроса

    async function fetchServiceLogs(params) { // Функция запроса сервисных логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем параметры запроса
      const response = await fetch(`/api/service-logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data; // Возвращаем полный ответ
    } // Конец функции запроса сервисных логов

    async function refreshLogs() { // Функция обновления таблицы
      try { // Блок попытки
        const params = {}; // Объект параметров запроса
        if (peerFilter.value) { // Если выбран чат
          params.peer_id = peerFilter.value; // Добавляем фильтр чата
        } // Конец условия
        if (limitInput.value) { // Если задан лимит
          params.limit = limitInput.value; // Добавляем лимит
        } // Конец условия
        const logs = await fetchLogs(params); // Получаем логи с сервера
        renderLogs(logs); // Отрисовываем таблицу
      } catch (err) { // Обработка ошибок
        console.error('Не удалось обновить логи', err); // Пишем в консоль
      } // Конец обработки
    } // Конец функции обновления

    async function clearLogs() { // Функция полной очистки логов сообщений
      const confirmed = window.confirm('Очистить все логи сообщений? Это действие удалит записи без возможности восстановления.'); // Спрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отказ
        return; // Прерываем выполнение при отмене
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/logs/clear', { method: 'POST' }); // Отправляем POST-запрос на очистку логов сообщений
        await refreshLogs(); // Перерисовываем таблицу после очистки
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить логи сообщений', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки логов сообщений

    async function refreshServiceLogs() { // Функция обновления сервисных логов
      try { // Блок попытки
        const params = {}; // Готовим параметры
        const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
        if (serviceTypeSelect.value) { // Если выбран тип
          params.event_type = serviceTypeSelect.value; // Добавляем тип
        } // Конец условия
        params.limit = limit; // Добавляем лимит
        params.offset = serviceOffset; // Добавляем смещение
        const result = await fetchServiceLogs(params); // Получаем данные
        serviceTotal = Number(result.total || 0); // Сохраняем количество
        renderServiceLogs(result.items || []); // Отрисовываем таблицу
        const end = Math.min(serviceOffset + limit, serviceTotal || 0); // Считаем конец диапазона
        servicePrevBtn.disabled = serviceOffset === 0; // Блокируем кнопку назад при нуле
        serviceNextBtn.disabled = serviceOffset + limit >= serviceTotal; // Блокируем кнопку вперед при достижении конца
        servicePageLabel.textContent = serviceTotal ? `Показано ${end} из ${serviceTotal}` : 'Нет данных'; // Обновляем подпись
      } catch (err) { // Обработка ошибок
        console.error('Не удалось обновить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции обновления сервисных логов

    async function clearServiceLogs() { // Функция очистки сервисных логов
      const confirmed = window.confirm('Очистить все сервисные логи? Это действие нельзя отменить.'); // Запрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отмену
        return; // Прерываем выполнение при отказе
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/service-logs/clear', { method: 'POST' }); // Отправляем POST очистки
        serviceOffset = 0; // Сбрасываем смещение
        await refreshServiceLogs(); // Перерисовываем таблицу
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки

    filtersForm.addEventListener('submit', (event) => { // Обработчик отправки формы
      event.preventDefault(); // Отменяем стандартное поведение
      refreshLogs(); // Перезапрашиваем логи
    }); // Конец обработчика формы

    logsBody.addEventListener('click', (event) => { // Делегированный обработчик кликов по таблице логов
      const deleteButton = event.target.closest('.delete-log-btn'); // Ищем кнопку удаления
      if (!deleteButton) { // Если клик не по кнопке удаления
        return; // Прерываем обработку
      } // Конец проверки назначения клика
      const recordId = deleteButton.dataset.logId; // Берем ID записи из data-атрибута
      if (!recordId) { // Если ID не найден
        return; // Завершаем без вызова API
      } // Конец проверки наличия ID
      deleteLog(recordId); // Запускаем удаление выбранной строки
    }); // Конец делегированного обработчика

    refreshBtn.addEventListener('click', () => { // Обработчик кнопки обновления
      refreshLogs(); // Перезапрашиваем логи
    }); // Конец обработчика кнопки

    clearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки логов сообщений
      event.preventDefault(); // Блокируем стандартное действие кнопки
      clearLogs(); // Запускаем очистку логов сообщений
    }); // Конец обработчика кнопки очистки

    serviceRefreshBtn.addEventListener('click', (event) => { // Обработчик обновления сервисных логов
      event.preventDefault(); // Отменяем действие кнопки
      refreshServiceLogs(); // Перезапрашиваем сервисные логи
    }); // Конец обработчика обновления

    serviceClearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки
      event.preventDefault(); // Отменяем действие кнопки
      clearServiceLogs(); // Запускаем очистку
    }); // Конец обработчика очистки

    serviceTypeSelect.addEventListener('change', () => { // Обработчик смены типа
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs(); // Перерисовываем данные
    }); // Конец обработчика смены типа

    serviceLimitInput.addEventListener('change', () => { // Обработчик смены лимита
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика смены лимита

    servicePrevBtn.addEventListener('click', () => { // Обработчик кнопки назад
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset = Math.max(0, serviceOffset - limit); // Уменьшаем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика кнопки назад

    serviceNextBtn.addEventListener('click', () => { // Обработчик кнопки вперед
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset += limit; // Увеличиваем смещение
      refreshServiceLogs(); // Обновляем таблицу
    }); // Конец обработчика кнопки вперед

    messagesTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сообщений
      switchToMessages(); // Показываем секцию сообщений
    }); // Конец обработчика вкладки сообщений

    serviceTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сервисных логов
      switchToService(); // Показываем секцию сервисных логов
      refreshServiceLogs(); // Перезапрашиваем сервисные логи при показе
    }); // Конец обработчика вкладки сервисных логов

    limitInput.value = initialLimit; // Устанавливаем стартовый лимит
    renderPeers(initialPeers || []); // Отрисовываем селектор чатов
    renderLogs(initialLogs || []); // Отрисовываем стартовые логи
    serviceTotal = (initialServiceLogs || []).length; // Запоминаем количество стартовых сервисных логов
    servicePageLabel.textContent = serviceTotal ? `Показано ${Math.min(serviceTotal, Number(serviceLimitInput.value) || 50)} из ${serviceTotal}` : 'Нет данных'; // Показываем подпись пагинации
    renderServiceLogs(initialServiceLogs || []); // Отрисовываем стартовые сервисные логи
    switchToMessages(); // Устанавливаем вкладку сообщений активной при загрузке
  </script> <!-- Конец скрипта -->
</body> <!-- Конец тела -->
</html> <!-- Конец документа -->
