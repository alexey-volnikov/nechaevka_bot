<!doctype html> <!-- Объявляем тип документа -->
<html lang="ru"> <!-- Устанавливаем язык страницы -->
<head> <!-- Начало шапки -->
  <meta charset="UTF-8" /> <!-- Кодировка -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- Адаптивность -->
  <title>Полные логи сообщений</title> <!-- Заголовок вкладки -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" /> <!-- Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com" /> <!-- Предзагрузка шрифтов -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> <!-- Кросс-домен для шрифтов -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" /> <!-- Шрифт Inter -->
  <style> /* Начало пользовательских стилей */
    body { background: #0f172a; color: #e2e8f0; font-family: "Inter", system-ui, -apple-system, sans-serif; } /* Фон и текст */
    .glass { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 18px; backdrop-filter: blur(10px); } /* Стеклянный стиль */
    .badge-soft { background: rgba(99, 102, 241, 0.15); color: #c7d2fe; border: 1px solid rgba(99, 102, 241, 0.35); } /* Мягкий бейдж */
    .table > :not(caption) > * > * { background-color: transparent; color: #e2e8f0; } /* Прозрачные ячейки */
    .table-striped > tbody > tr:nth-of-type(odd) > * { background: rgba(255, 255, 255, 0.03); } /* Полосатость */
    .chat-table { table-layout: fixed; width: 100%; } /* Сетка для вспомогательных таблиц */
    .chat-table th, .chat-table td { font-size: 11px; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 0; } /* Компактный стиль для вспомогательных таблиц */
    .chat-feed { display: flex; flex-direction: column; gap: 12px; margin: 0; padding: 0; list-style: none; } /* Воздушная вертикальная лента сообщений без маркеров */
    .chat-item { display: flex; gap: 10px; align-items: flex-start; padding: 4px 0; } /* Строка ленты без отдельной обводки вокруг пузыря */
    .chat-bubble { flex: 1; display: flex; flex-direction: column; gap: 8px; background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.08), transparent 45%), linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.85)); border: 1px solid rgba(148, 163, 184, 0.25); border-radius: 14px; padding: 10px 12px; box-shadow: 0 12px 28px rgba(0, 0, 0, 0.25); } /* Пузырь сообщения в стиле Telegram с мягким свечением */
    .chat-bubble-top { display: flex; flex-direction: column; gap: 4px; } /* Верхняя часть пузыря с подписями */
    .chat-bubble-headline { display: flex; align-items: center; justify-content: space-between; gap: 8px; } /* Строка автора и времени */
    .chat-bubble-author-line { display: inline-flex; align-items: center; gap: 10px; flex-wrap: nowrap; } /* Линия автора с аватаром рядом в одном фрейме */
    .chat-bubble-meta-line { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; font-size: 12px; color: #a5b4fc; } /* Строка с названием чата и дополнительными метками */
    .chat-bubble-meta { display: inline-flex; align-items: center; gap: 6px; font-weight: 700; color: #e2e8f0; } /* Название чата в подписи */
    .chat-bubble-author { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; font-weight: 700; color: #e2e8f0; } /* Имя отправителя в стиле мессенджера */
    .chat-bubble-reply { border-left: 2px solid rgba(148, 163, 184, 0.4); padding-left: 10px; color: #cbd5e1; font-size: 12px; } /* Превью ответа с аккуратной полоской слева */
    .chat-bubble-attachments { display: flex; flex-wrap: wrap; gap: 6px; } /* Группа вложений внутри пузыря с небольшими зазорами */
    .chat-bubble-text { font-size: 14px; line-height: 1.5; color: #e2e8f0; white-space: pre-wrap; } /* Основной текст сообщения с комфортным кеглем */
    .chat-bubble-footer { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; font-size: 11px; color: #cbd5e1; } /* Подвал карточки с бейджами и кнопками */
    .chat-flag-pill { display: inline-flex; align-items: center; gap: 6px; padding: 3px 10px; border-radius: 999px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(148, 163, 184, 0.12); color: #cbd5e1; font-size: 11px; } /* Плашка для статусов поверх пузыря */
    .shadow-soft { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25); } /* Мягкая тень */
    .service-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 12px; font-size: 12px; } /* Пилюля статуса */
    .service-pill.info { background: rgba(56, 189, 248, 0.2); color: #bae6fd; border: 1px solid rgba(56, 189, 248, 0.5); } /* Цвет инфо */
    .service-pill.warning { background: rgba(234, 179, 8, 0.2); color: #fef08a; border: 1px solid rgba(234, 179, 8, 0.5); } /* Цвет предупреждения */
    .service-pill.error { background: rgba(248, 113, 113, 0.2); color: #fecdd3; border: 1px solid rgba(248, 113, 113, 0.5); } /* Цвет ошибки */
    .service-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; } /* Точка индикации */
    .service-dot.info { background: #38bdf8; } /* Цвет точки инфо */
    .service-dot.warning { background: #fbbf24; } /* Цвет точки предупреждения */
    .service-dot.error { background: #f87171; } /* Цвет точки ошибки */
    .avatar-inline { width: 1.6em; height: 1.6em; border-radius: 999px; object-fit: cover; flex-shrink: 0; } /* Класс компактной аватарки */
    .avatar-shell { width: 36px; height: 36px; border-radius: 999px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.12); } /* Контейнер для аватарки без подписи, чтобы не дублировать имя */
    .avatar-shell img { width: 100%; height: 100%; object-fit: cover; } /* Растягиваем картинку на весь контейнер, убирая текст */
    .avatar-shell-placeholder { font-weight: 700; color: #e2e8f0; font-size: 14px; } /* Плейсхолдер с буквой, если аватарки нет и подпись уже есть в пузыре */
    .attachment-pill { display: inline-flex; gap: 6px; align-items: center; padding: 4px 10px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.05); color: #e2e8f0; font-size: 12px; text-decoration: none; } /* Пилюля вложения */
    .attachment-pill:hover { text-decoration: none; background: rgba(255, 255, 255, 0.08); } /* Подсветка вложения */
    .attachment-pending { border-style: dashed; background: rgba(59, 130, 246, 0.18); color: #cbd5e1; } /* Акцент ожидания скачивания вложения */
    .attachment-failed { border-style: dashed; background: rgba(248, 113, 113, 0.2); color: #fecaca; border-color: rgba(248, 113, 113, 0.5); } /* Подсветка ошибок скачивания */
    .attachment-photo { border-color: rgba(59, 130, 246, 0.5); color: #bfdbfe; } /* Цвет фото */
    .attachment-video { border-color: rgba(244, 114, 182, 0.5); color: #fbcfe8; } /* Цвет видео */
    .attachment-doc { border-color: rgba(74, 222, 128, 0.5); color: #bbf7d0; } /* Цвет документов */
    .attachment-audio { border-color: rgba(56, 189, 248, 0.5); color: #bae6fd; } /* Цвет аудио */
    .attachment-sticker { border-color: rgba(248, 180, 0, 0.6); color: #fef08a; } /* Цвет стикеров */
    .attachment-wall { border-color: rgba(236, 72, 153, 0.6); color: #fbcfe8; } /* Цвет постов */
    .attachment-link { border-color: rgba(14, 165, 233, 0.5); color: #bae6fd; } /* Цвет ссылок */
    .attachment-generic { border-color: rgba(148, 163, 184, 0.5); color: #e2e8f0; } /* Цвет прочих вложений */
    .attachment-group { display: flex; flex-wrap: wrap; gap: 6px; } /* Группа вложений */
    .copy-block { display: flex; flex-direction: column; gap: 4px; padding: 6px 10px; border-radius: 12px; border: 1px dashed rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.02); } /* Блок репоста */
    .copy-header { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cbd5e1; } /* Заголовок репоста */
    .copy-attachments { display: flex; flex-wrap: wrap; gap: 6px; } /* Вложения репоста */
    .content-cell { display: flex; flex-direction: column; gap: 6px; } /* Ячейка контента */
    .gallery-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 16px; } /* Фон модалки */
    .gallery-body { background: #0b1220; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; max-width: 900px; width: 100%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35); display: flex; flex-direction: column; gap: 12px; padding: 16px; } /* Корпус модалки */
    .gallery-media { position: relative; min-height: 320px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.03); border-radius: 12px; overflow: hidden; } /* Блок медиа */
    .gallery-media img, .gallery-media video { max-height: 540px; width: 100%; object-fit: contain; border-radius: 12px; background: #0b1220; } /* Медиа в модалке */
    .gallery-actions { display: flex; align-items: center; justify-content: space-between; gap: 12px; } /* Панель кнопок */
    .gallery-meta { display: flex; flex-direction: column; gap: 4px; font-size: 14px; color: #cbd5e1; } /* Текст описания */
    .gallery-nav-btn { min-width: 42px; } /* Минимальная ширина кнопок навигации */
    .gallery-thumb { margin: 2px; } /* Отступы кнопок миниатюр */
    .gallery-thumb.active { border-width: 2px !important; } /* Подсветка активного элемента */
    .message-deleted { border-color: rgba(248, 113, 113, 0.35) !important; } /* Обводка карточки удаленного сообщения */
    .message-deleted .chat-bubble { background: rgba(127, 29, 29, 0.3); border-color: rgba(248, 113, 113, 0.5); color: #fecdd3; } /* Красноватый фон и текст пузыря удаленного сообщения */
    .message-deleted a { color: #fecdd3; } /* Красноватый цвет ссылок в удаленных сообщениях */
  </style> <!-- Конец стилей -->
</head> <!-- Конец шапки -->
<body class="pb-5"> <!-- Тело страницы -->
  <div class="container py-4"> <!-- Контейнер -->
    <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-3 mb-4"> <!-- Заголовок страницы -->
      <div> <!-- Левая часть -->
        <div class="d-inline-flex align-items-center gap-2 mb-2"> <!-- Бейдж -->
          <span class="badge-soft badge rounded-pill"> <!-- Обертка бейджа -->
            Полные логи <!-- Подпись -->
          </span> <!-- Конец бейджа -->
        </div> <!-- Конец блока бейджа -->
        <h1 class="fw-bold mb-1">Все сообщения</h1> <!-- Заголовок -->
        <p class="text-secondary mb-0">Лента без общего лимита, старые записи догружаются при прокрутке.</p> <!-- Подзаголовок -->
      </div> <!-- Конец левой части -->
      <div class="d-flex flex-wrap gap-2"> <!-- Правая часть с кнопками -->
        <a href="/" class="btn btn-outline-light">Вернуться к дашборду</a> <!-- Кнопка назад -->
        <button id="refresh-btn" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
        <button id="clear-btn" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки логов сообщений -->
      </div> <!-- Конец правой части -->
    </div> <!-- Конец заголовка страницы -->

    <ul class="nav nav-pills mb-4 gap-2 flex-wrap"> <!-- Панель вкладок -->
      <li class="nav-item"> <!-- Пункт вкладки сообщений -->
        <button id="messages-tab-btn" class="nav-link active text-light bg-primary" type="button">Логи сообщений</button> <!-- Кнопка вкладки сообщений -->
      </li> <!-- Конец пункта вкладки сообщений -->
      <li class="nav-item"> <!-- Пункт вкладки сервисных логов -->
        <button id="service-tab-btn" class="nav-link text-light bg-dark border border-secondary" type="button">Сервисные логи</button> <!-- Кнопка вкладки сервисных логов -->
      </li> <!-- Конец пункта вкладки сервисных логов -->
    </ul> <!-- Конец панели вкладок -->

    <div id="messages-section" class="d-block"> <!-- Секция логов сообщений -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров -->
        <form id="filters-form" class="row g-3 align-items-end"> <!-- Форма фильтров -->
          <div class="col-12 col-md-5"> <!-- Колонка селектора чатов -->
            <label class="form-label text-secondary small" for="peer-filter">Фильтр по peer_id</label> <!-- Подпись -->
            <select id="peer-filter" name="peer_id" class="form-select bg-dark text-light border-secondary"> <!-- Селектор -->
              <option value="">Все чаты</option> <!-- Опция по умолчанию -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-7 d-flex gap-2"> <!-- Колонка кнопок -->
            <button type="submit" class="btn btn-primary flex-grow-1">Применить фильтр</button> <!-- Кнопка отправки -->
            <a href="/logs/full" class="btn btn-outline-light">Сбросить</a> <!-- Кнопка сброса -->
          </div> <!-- Конец колонки кнопок -->
        </form> <!-- Конец формы -->
      </div> <!-- Конец блока фильтров -->

      <div class="glass shadow-soft p-4"> <!-- Блок таблицы -->
        <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок таблицы -->
          <div> <!-- Левая часть -->
            <div class="card-title mb-1">Логи сообщений</div> <!-- Название -->
            <div class="text-secondary small">Содержимое базы с именами, чатами и вложениями.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center gap-2"> <!-- Контейнер бейджей -->
            <span class="badge-soft badge rounded-pill" id="timezone-hint" title="">Локальное время</span> <!-- Бейдж с подсказкой о таймзоне -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
          </div> <!-- Конец контейнера бейджей -->
        </div> <!-- Конец заголовка таблицы -->
        <div id="logs-body" class="chat-feed"> <!-- Лента логов в виде чата -->
          <div class="text-secondary" id="logs-placeholder">Нет данных</div> <!-- Плейсхолдер при пустой ленте -->
        </div> <!-- Конец ленты логов -->
      </div> <!-- Конец блока таблицы -->
    </div> <!-- Конец секции логов сообщений -->

    <div id="service-section" class="d-none"> <!-- Секция сервисных логов -->
      <div class="glass shadow-soft p-4 mb-4"> <!-- Блок фильтров сервисных логов -->
        <form id="service-filters" class="row g-3 align-items-end"> <!-- Форма фильтра сервисных логов -->
          <div class="col-12 col-md-4"> <!-- Колонка типа события -->
            <label class="form-label text-secondary small" for="service-type">Тип оповещения</label> <!-- Подпись -->
            <select id="service-type" class="form-select bg-dark text-light border-secondary"> <!-- Селектор типа -->
              <option value="">Все</option> <!-- Опция все -->
              <option value="important">Важные (warning+error)</option> <!-- Опция важных -->
              <option value="error">Только ошибки</option> <!-- Опция ошибок -->
              <option value="warning">Предупреждения</option> <!-- Опция предупреждений -->
              <option value="info">Информационные</option> <!-- Опция инфо -->
            </select> <!-- Конец селектора -->
          </div> <!-- Конец колонки -->
          <div class="col-12 col-md-3"> <!-- Колонка лимита -->
            <label class="form-label text-secondary small" for="service-limit">Лимит строк</label> <!-- Подпись -->
            <input type="number" id="service-limit" class="form-control bg-dark text-light border-secondary" min="1" max="200" value="50" /> <!-- Поле лимита -->
          </div> <!-- Конец колонки лимита -->
          <div class="col-12 col-md-5"> <!-- Колонка пагинации -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер кнопок -->
              <button id="service-prev" class="btn btn-outline-light flex-grow-1" type="button">Назад</button> <!-- Кнопка назад -->
              <button id="service-next" class="btn btn-outline-light flex-grow-1" type="button">Вперед</button> <!-- Кнопка вперед -->
              <span id="service-page" class="text-secondary small">—</span> <!-- Подпись страницы -->
            </div> <!-- Конец контейнера -->
          </div> <!-- Конец колонки -->
        </form> <!-- Конец формы фильтра -->
      </div> <!-- Конец блока фильтров сервисных логов -->

      <div id="service-alerts" class="glass shadow-soft p-4"> <!-- Блок сервисных оповещений -->
        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3 mb-3"> <!-- Заголовок блока -->
          <div> <!-- Левая часть заголовка -->
            <div class="card-title mb-1">Сервисные оповещения</div> <!-- Заголовок текста -->
            <div class="text-secondary small">Ошибки, предупреждения и информирование о работе сервиса.</div> <!-- Подпись -->
          </div> <!-- Конец левой части -->
          <div class="d-flex align-items-center flex-wrap gap-2"> <!-- Правая часть с элементами -->
            <span class="badge-soft badge rounded-pill" id="service-timezone-hint" title="">Локальное время</span> <!-- Бейдж подсказки таймзоны -->
            <span class="badge bg-secondary">READ ONLY</span> <!-- Бейдж режима -->
            <div class="d-flex flex-wrap gap-2"> <!-- Группа кнопок -->
              <button id="service-refresh" class="btn btn-info text-dark">Обновить</button> <!-- Кнопка обновления -->
              <button id="service-clear" class="btn btn-outline-light">Очистить логи</button> <!-- Кнопка очистки -->
            </div> <!-- Конец группы кнопок -->
          </div> <!-- Конец правой части -->
        </div> <!-- Конец заголовка блока -->
        <div class="table-responsive"> <!-- Обертка таблицы сервисных логов -->
          <table class="table table-striped align-middle mb-0"> <!-- Таблица сервисных логов -->
            <thead class="text-secondary"> <!-- Заголовок таблицы -->
              <tr> <!-- Строка заголовка -->
                <th>Время</th> <!-- Колонка времени -->
                <th>Тип</th> <!-- Колонка типа -->
                <th>Код</th> <!-- Колонка кода -->
                <th>Пояснение</th> <!-- Колонка пояснения -->
                <th>Сообщение</th> <!-- Колонка текста -->
              </tr> <!-- Конец строки -->
            </thead> <!-- Конец шапки -->
            <tbody id="service-logs-body"> <!-- Тело таблицы сервисных логов -->
              <tr> <!-- Плейсхолдер -->
                <td colspan="5" class="text-secondary">Нет данных</td> <!-- Текст плейсхолдера -->
              </tr> <!-- Конец плейсхолдера -->
            </tbody> <!-- Конец тела -->
          </table> <!-- Конец таблицы -->
        </div> <!-- Конец обертки -->
      </div> <!-- Конец блока сервисных оповещений -->
    </div> <!-- Конец секции сервисных логов -->
  </div> <!-- Конец контейнера -->

  {% include 'partials/gallery.html' %} <!-- Подключаем общую разметку модального окна галереи -->

  <script src="{{ url_for('static', filename='js/gallery.js') }}"></script> <!-- Подключаем общий скрипт галереи -->
  <script src="{{ url_for('static', filename='js/chat-history.js') }}"></script> <!-- Подключаем единый модуль истории чата -->
  <script> // Начало скрипта
    const initialLogs = {{ initial_logs|tojson }}; // Стартовые логи из шаблона
    const initialPeers = {{ initial_peers|tojson }}; // Стартовый список чатов
    const initialPeerId = {{ initial_peer_id|tojson }}; // Стартовый peer_id
    const initialPageSize = {{ initial_page_size|tojson }}; // Размер страницы подгрузки
    const initialServiceLogs = {{ initial_service_logs|tojson }}; // Стартовые сервисные логи

    const logsBody = document.getElementById('logs-body'); // Лента логов в формате чата
    const peerFilter = document.getElementById('peer-filter'); // Селектор чатов
    const refreshBtn = document.getElementById('refresh-btn'); // Кнопка обновления
    const clearBtn = document.getElementById('clear-btn'); // Кнопка очистки логов сообщений
    const filtersForm = document.getElementById('filters-form'); // Форма фильтров
    const serviceBody = document.getElementById('service-logs-body'); // Тело таблицы сервисных логов
    const serviceTypeSelect = document.getElementById('service-type'); // Селектор типа сервисных событий
    const serviceLimitInput = document.getElementById('service-limit'); // Поле лимита сервисных событий
    const servicePrevBtn = document.getElementById('service-prev'); // Кнопка назад
    const serviceNextBtn = document.getElementById('service-next'); // Кнопка вперед
    const servicePageLabel = document.getElementById('service-page'); // Текст пагинации
    const serviceRefreshBtn = document.getElementById('service-refresh'); // Кнопка обновления сервисных логов
    const serviceClearBtn = document.getElementById('service-clear'); // Кнопка очистки сервисных логов
    const messagesSection = document.getElementById('messages-section'); // Секция логов сообщений
    const serviceSection = document.getElementById('service-section'); // Секция сервисных логов
    const messagesTabBtn = document.getElementById('messages-tab-btn'); // Кнопка вкладки сообщений
    const serviceTabBtn = document.getElementById('service-tab-btn'); // Кнопка вкладки сервисных логов
    const galleryApi = window.galleryBridge || {}; // Получаем общий API галереи из подключенного файла
    const chatApi = window.chatHistory || {}; // Получаем единый модуль истории чата
    let galleryCounter = 0; // Счетчик для генерации ключей галерей
    let logOffset = Array.isArray(initialLogs) ? initialLogs.length : 0; // Смещение для следующей страницы логов
    let hasMoreLogs = Array.isArray(initialLogs) && initialLogs.length === initialPageSize; // Флаг наличия следующих страниц логов
    let isLoadingLogs = false; // Флаг процесса загрузки логов
    let currentPeerId = initialPeerId; // Текущий активный фильтр чата
    let serviceOffset = 0; // Текущее смещение сервисных логов
    let serviceTotal = 0; // Общее количество сервисных событий
    const serviceHashRequested = window.location.hash.includes('service-alerts'); // Флаг наличия якоря сервисных логов в URL
    if (serviceHashRequested) { // Если в адресе сразу указаны сервисные логи
        serviceTypeSelect.value = 'important'; // Ставим фильтр «Важные» до загрузки данных
      } // Конец предварительной установки фильтра

    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions(); // Читаем параметры локальной таймзоны
    const timezoneOffsetMinutes = new Date().getTimezoneOffset(); // Получаем смещение в минутах относительно UTC
    const timezoneOffsetSign = timezoneOffsetMinutes <= 0 ? '+' : '-'; // Определяем знак смещения
    const timezoneOffsetHours = String(Math.floor(Math.abs(timezoneOffsetMinutes) / 60)).padStart(2, '0'); // Вычисляем часы смещения
    const timezoneOffsetRestMinutes = String(Math.abs(timezoneOffsetMinutes) % 60).padStart(2, '0'); // Вычисляем минуты смещения
    const timezoneLabel = `UTC${timezoneOffsetSign}${timezoneOffsetHours}:${timezoneOffsetRestMinutes} (${timezoneInfo.timeZone || 'локальное время'})`; // Формируем строку подсказки
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: timezoneInfo.timeZone, timeZoneName: 'short' }); // Настраиваем форматер локального времени

    document.getElementById('timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сообщений
    document.getElementById('service-timezone-hint').title = `Отображается время ${timezoneLabel}`; // Заполняем подсказку бейджа таймзоны для сервисных логов

    function formatDateTime(value) { // Функция форматирования даты в локальное время
      const parsed = value ? new Date(value) : null; // Парсим строку даты
      return parsed && !Number.isNaN(parsed.valueOf()) ? timeFormatter.format(parsed) : '—'; // Возвращаем отформатированное значение или тире
    } // Конец функции форматирования

    function switchToMessages() { // Функция показа вкладки сообщений
      messagesSection.classList.remove('d-none'); // Убираем скрытие секции сообщений
      messagesSection.classList.add('d-block'); // Добавляем показ секции сообщений
      serviceSection.classList.add('d-none'); // Скрываем секцию сервисных логов
      serviceSection.classList.remove('d-block'); // Убираем класс показа сервисных логов
      messagesTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сообщений
      messagesTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки
      serviceTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с сервисной вкладки
      serviceTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сервисной вкладки
    } // Конец функции переключения на сообщения

    function switchToService() { // Функция показа вкладки сервисных логов
      serviceSection.classList.remove('d-none'); // Убираем скрытие секции сервисных логов
      serviceSection.classList.add('d-block'); // Добавляем показ секции сервисных логов
      messagesSection.classList.add('d-none'); // Скрываем секцию сообщений
      messagesSection.classList.remove('d-block'); // Убираем класс показа секции сообщений
      serviceTabBtn.classList.add('active', 'bg-primary'); // Подсвечиваем кнопку сервисных логов
      serviceTabBtn.classList.remove('bg-dark', 'border', 'border-secondary'); // Убираем стили неактивной кнопки сервисной вкладки
      messagesTabBtn.classList.remove('active', 'bg-primary'); // Убираем активность с вкладки сообщений
      messagesTabBtn.classList.add('bg-dark', 'border', 'border-secondary'); // Добавляем стили неактивной кнопки сообщений
    } // Конец функции переключения на сервисные логи

    function handleHashNavigation() { // Обрабатываем якорь в адресной строке
      const wantsService = window.location.hash.includes('service-alerts'); // Проверяем, нужен ли раздел сервисных логов
      if (wantsService) { // Если нужно открыть сервисные логи
        serviceTypeSelect.value = 'important'; // Ставим фильтр «Важные» по умолчанию
        serviceOffset = 0; // Сбрасываем смещение пагинации
        switchToService(); // Переключаемся на вкладку сервисных логов
        refreshServiceLogs({ markAsRead: true }); // Обновляем таблицу с новым фильтром и сбрасываем счетчик
      } else { // Если якоря нет или он другой
        switchToMessages(); // Возвращаемся на вкладку логов сообщений
      } // Конец проверки якоря
    } // Конец функции обработки якоря

    function renderPeers(peers) { // Функция отрисовки списка чатов
      peerFilter.innerHTML = '<option value="">Все чаты</option>'; // Сбрасываем селектор
      (peers || []).forEach((peer) => { // Перебираем чаты
        if (!peer || !Number.isFinite(peer.id)) return; // Пропускаем некорректные записи
        const option = document.createElement('option'); // Создаем опцию
        option.value = peer.id; // Значение опции
        const label = peer.title ? `${peer.title} (ID: ${peer.id})` : peer.id; // Подпись опции
        option.textContent = label; // Текст опции
        peerFilter.appendChild(option); // Добавляем опцию
      }); // Конец цикла
      if (initialPeerId !== null) { // Если стартовый фильтр задан
        peerFilter.value = initialPeerId; // Устанавливаем значение
      } // Конец условия
    } // Конец функции отрисовки чатов

    function resetGalleryStore() { // Очищаем хранилище галереи перед полной перерисовкой
      if (galleryApi.resetGalleryStorePreserveActive) { // Проверяем наличие функции очистки
        galleryApi.resetGalleryStorePreserveActive(); // Очищаем хранилище, сохраняя открытую галерею
      } // Конец проверки наличия функции
    } // Конец функции очистки галереи

    function renderLogs(logs, { append = false } = {}) { // Функция отрисовки ленты логов с дописыванием
      if (!append) { // Если перерисовываем полностью
        logsBody.innerHTML = ''; // Очищаем ленту
        resetGalleryStore(); // Сбрасываем галерею
        galleryCounter = 0; // Сбрасываем счетчик ключей галереи
      } // Конец проверки режима отрисовки
      if (!Array.isArray(logs) || logs.length === 0) { // Проверяем наличие данных
        if (!append) { // Если данных нет и это полная перерисовка
          logsBody.innerHTML = '<div class="text-secondary" id="logs-placeholder">Нет данных</div>'; // Плейсхолдер
        } // Конец проверки режима
        return; // Прерываем выполнение при отсутствии данных
      } // Конец проверки массива данных
      if (append) { // Если добавляем новые записи
        const placeholderRow = document.getElementById('logs-placeholder'); // Ищем плейсхолдер
        if (placeholderRow) { // Проверяем, найден ли плейсхолдер
          placeholderRow.remove(); // Удаляем плейсхолдер перед добавлением данных
        } // Конец проверки наличия плейсхолдера
      } // Конец проверки режима добавления
      logs.forEach((log) => { // Перебираем логи
        const galleryKey = `log-${log.id ?? 'local'}-${galleryCounter++}`; // Формируем ключ галереи для записи
        const row = chatApi.buildLogsRow(log, galleryApi, galleryKey, { formatDate: formatDateTime }); // Собираем карточку через единый модуль истории чата
        logsBody.appendChild(row); // Добавляем карточку в ленту
      }); // Конец цикла
    } // Конец функции отрисовки

    async function deleteLog(recordId) { // Функция удаления одной записи
      const confirmed = window.confirm('Удалить выбранную строку лога сообщений? Действие необратимо.'); // Подтверждаем действие
      if (!confirmed) { // Если пользователь отказался
        return; // Прерываем удаление
      } // Конец проверки согласия
      try { // Пытаемся выполнить запрос
        const response = await fetch(`/api/logs/${recordId}`, { method: 'DELETE' }); // Отправляем запрос удаления
        if (!response.ok) { // Проверяем код ответа
          throw new Error('Удаление завершилось ошибкой'); // Бросаем исключение при проблеме
        } // Конец проверки кода ответа
        await loadLogs({ reset: true }); // Перерисовываем таблицу после удаления
      } catch (err) { // Обработка ошибки
        console.error('Не удалось удалить запись лога', err); // Логируем проблему
      } // Конец обработки
    } // Конец функции удаления записи

    function renderServiceLogs(logs) { // Функция отрисовки сервисных оповещений
      serviceBody.innerHTML = ''; // Очищаем тело таблицы
      if (!logs.length) { // Проверяем наличие данных
        serviceBody.innerHTML = '<tr><td colspan="5" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Завершаем функцию
      } // Конец проверки
      logs.forEach((log) => { // Перебираем оповещения
        const row = document.createElement('tr'); // Создаем строку
        const type = log.event_type || 'info'; // Определяем тип события
        const badgeClass = `service-pill ${type}`; // Готовим класс пилюли
        const dotClass = `service-dot ${type}`; // Готовим класс точки
        const createdAt = formatDateTime(log.created_at); // Форматируем время сервисного события
        row.innerHTML = `<td>${createdAt}</td><td><span class="${badgeClass}"><span class="${dotClass}"></span>${type}</span></td><td>${log.status_code ?? '—'}</td><td>${log.description ?? '—'}</td><td>${log.message ?? ''}</td>`; // Заполняем строку
        serviceBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции отрисовки сервисных логов

    function buildLogParams(offsetValue) { // Формируем параметры запроса логов
      const params = { limit: initialPageSize, offset: offsetValue }; // Добавляем базовые параметры пагинации
      if (currentPeerId) { // Если выбран чат
        params.peer_id = currentPeerId; // Передаем peer_id
      } // Конец проверки выбранного чата
      return params; // Возвращаем параметры
    } // Конец функции подготовки параметров

    async function fetchLogs(params) { // Функция запроса логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем объект параметров
      const response = await fetch(`/api/logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data.items || []; // Возвращаем список логов
    } // Конец функции запроса

    async function fetchServiceLogs(params) { // Функция запроса сервисных логов с сервера
      const searchParams = new URLSearchParams(params); // Создаем параметры запроса
      const response = await fetch(`/api/service-logs?${searchParams.toString()}`); // Отправляем запрос
      const data = await response.json(); // Читаем JSON
      return data; // Возвращаем полный ответ
    } // Конец функции запроса сервисных логов

    async function loadLogs({ reset = false } = {}) { // Функция подгрузки сообщений с поддержкой бесконечной ленты
      if (isLoadingLogs) { // Проверяем, идет ли загрузка
        return; // Прерываем повторный вызов
      } // Конец проверки параллельной загрузки
      if (!hasMoreLogs && !reset) { // Проверяем, есть ли еще данные при попытке догрузки
        return; // Прерываем, если все записи уже загружены
      } // Конец проверки наличия данных
      if (reset) { // Если нужно начать загрузку с начала
        logOffset = 0; // Сбрасываем смещение
        hasMoreLogs = true; // Возвращаем флаг наличия данных
        renderLogs([], { append: false }); // Очищаем таблицу перед новой загрузкой
      } // Конец проверки сброса
      isLoadingLogs = true; // Ставим флаг загрузки
      try { // Блок попытки загрузки
        const params = buildLogParams(logOffset); // Формируем параметры
        const nextLogs = await fetchLogs(params); // Запрашиваем страницу логов
        if (reset) { // Если это полная перезагрузка
          renderLogs(nextLogs, { append: false }); // Рисуем таблицу заново
        } else { // Если догружаем вниз
          renderLogs(nextLogs, { append: true }); // Добавляем строки в конец
        } // Конец ветвления режима
        logOffset += nextLogs.length; // Увеличиваем смещение
        hasMoreLogs = nextLogs.length === initialPageSize; // Обновляем флаг наличия данных
      } catch (err) { // Обработка ошибки загрузки
        console.error('Не удалось обновить логи', err); // Пишем в консоль
        hasMoreLogs = false; // Останавливаем дальнейшую догрузку
      } finally { // Завершаем загрузку
        isLoadingLogs = false; // Сбрасываем флаг загрузки
      } // Конец блока завершения
    } // Конец функции подгрузки логов

    async function clearLogs() { // Функция полной очистки логов сообщений
      const confirmed = window.confirm('Очистить все логи сообщений? Это действие удалит записи без возможности восстановления.'); // Спрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отказ
        return; // Прерываем выполнение при отмене
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/logs/clear', { method: 'POST' }); // Отправляем POST-запрос на очистку логов сообщений
        await loadLogs({ reset: true }); // Перерисовываем таблицу после очистки
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить логи сообщений', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки логов сообщений

    async function refreshServiceLogs({ markAsRead = false } = {}) { // Функция обновления сервисных логов
      try { // Блок попытки
        const params = {}; // Готовим параметры
        const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
        if (serviceTypeSelect.value) { // Если выбран тип
          params.event_type = serviceTypeSelect.value; // Добавляем тип
        } // Конец условия
        if (markAsRead) { // Если нужно отметить важные события как прочитанные
          params.mark_read = '1'; // Передаем флаг сброса счётчика
        } // Конец проверки сброса
        params.limit = limit; // Добавляем лимит
        params.offset = serviceOffset; // Добавляем смещение
        const result = await fetchServiceLogs(params); // Получаем данные
        serviceTotal = Number(result.total || 0); // Сохраняем количество
        renderServiceLogs(result.items || []); // Отрисовываем таблицу
        const end = Math.min(serviceOffset + limit, serviceTotal || 0); // Считаем конец диапазона
        servicePrevBtn.disabled = serviceOffset === 0; // Блокируем кнопку назад при нуле
        serviceNextBtn.disabled = serviceOffset + limit >= serviceTotal; // Блокируем кнопку вперед при достижении конца
        servicePageLabel.textContent = serviceTotal ? `Показано ${end} из ${serviceTotal}` : 'Нет данных'; // Обновляем подпись
      } catch (err) { // Обработка ошибок
        console.error('Не удалось обновить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции обновления сервисных логов

    async function clearServiceLogs() { // Функция очистки сервисных логов
      const confirmed = window.confirm('Очистить все сервисные логи? Это действие нельзя отменить.'); // Запрашиваем подтверждение пользователя
      if (!confirmed) { // Проверяем отмену
        return; // Прерываем выполнение при отказе
      } // Конец проверки подтверждения
      try { // Пытаемся выполнить запрос
        await fetch('/api/service-logs/clear', { method: 'POST' }); // Отправляем POST очистки
        serviceOffset = 0; // Сбрасываем смещение
        await refreshServiceLogs(); // Перерисовываем таблицу
      } catch (err) { // Обработка ошибок
        console.error('Не удалось очистить сервисные логи', err); // Пишем ошибку в консоль
      } // Конец обработки
    } // Конец функции очистки

    function handleScrollForLogs() { // Обработчик прокрутки страницы для бесконечной ленты
      const scrollPosition = window.scrollY + window.innerHeight; // Текущая позиция прокрутки
      const threshold = document.documentElement.scrollHeight - 400; // Порог, при достижении которого начинаем подгрузку
      if (scrollPosition >= threshold) { // Проверяем, достигнут ли порог
        loadLogs(); // Запускаем подгрузку следующей страницы
      } // Конец проверки порога
    } // Конец обработчика прокрутки

    filtersForm.addEventListener('submit', (event) => { // Обработчик отправки формы
      event.preventDefault(); // Отменяем стандартное поведение
      currentPeerId = peerFilter.value || null; // Сохраняем выбранный чат
      loadLogs({ reset: true }); // Перезапрашиваем логи с начала
    }); // Конец обработчика формы

    logsBody.addEventListener('click', (event) => { // Делегированный обработчик кликов по таблице логов
      const deleteButton = event.target.closest('.delete-log-btn'); // Ищем кнопку удаления
      if (!deleteButton) { // Если клик не по кнопке удаления
        return; // Прерываем обработку
      } // Конец проверки назначения клика
      const recordId = deleteButton.dataset.logId; // Берем ID записи из data-атрибута
      if (!recordId) { // Если ID не найден
        return; // Завершаем без вызова API
      } // Конец проверки наличия ID
      deleteLog(recordId); // Запускаем удаление выбранной строки
    }); // Конец делегированного обработчика

    refreshBtn.addEventListener('click', () => { // Обработчик кнопки обновления
      loadLogs({ reset: true }); // Перезапрашиваем логи с начала
    }); // Конец обработчика кнопки

    clearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки логов сообщений
      event.preventDefault(); // Блокируем стандартное действие кнопки
      clearLogs(); // Запускаем очистку логов сообщений
    }); // Конец обработчика кнопки очистки

    serviceRefreshBtn.addEventListener('click', (event) => { // Обработчик обновления сервисных логов
      event.preventDefault(); // Отменяем действие кнопки
      refreshServiceLogs({ markAsRead: true }); // Перезапрашиваем сервисные логи с пометкой прочитанных
    }); // Конец обработчика обновления

    serviceClearBtn.addEventListener('click', (event) => { // Обработчик кнопки очистки
      event.preventDefault(); // Отменяем действие кнопки
      clearServiceLogs(); // Запускаем очистку
    }); // Конец обработчика очистки

    serviceTypeSelect.addEventListener('change', () => { // Обработчик смены типа
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs({ markAsRead: true }); // Перерисовываем данные и сбрасываем счетчик важных
    }); // Конец обработчика смены типа

    serviceLimitInput.addEventListener('change', () => { // Обработчик смены лимита
      serviceOffset = 0; // Сбрасываем смещение
      refreshServiceLogs({ markAsRead: true }); // Обновляем таблицу и отмечаем прочитанное
    }); // Конец обработчика смены лимита

    servicePrevBtn.addEventListener('click', () => { // Обработчик кнопки назад
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset = Math.max(0, serviceOffset - limit); // Уменьшаем смещение
      refreshServiceLogs({ markAsRead: true }); // Обновляем таблицу и сбрасываем непрочитанные
    }); // Конец обработчика кнопки назад

    serviceNextBtn.addEventListener('click', () => { // Обработчик кнопки вперед
      const limit = Number(serviceLimitInput.value) || 50; // Читаем лимит
      serviceOffset += limit; // Увеличиваем смещение
      refreshServiceLogs({ markAsRead: true }); // Обновляем таблицу и сбрасываем непрочитанные
    }); // Конец обработчика кнопки вперед

    messagesTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сообщений
      switchToMessages(); // Показываем секцию сообщений
    }); // Конец обработчика вкладки сообщений

    serviceTabBtn.addEventListener('click', () => { // Обработчик переключения на вкладку сервисных логов
      switchToService(); // Показываем секцию сервисных логов
      refreshServiceLogs({ markAsRead: true }); // Перезапрашиваем сервисные логи при показе и помечаем прочитанные
    }); // Конец обработчика вкладки сервисных логов

    window.addEventListener('hashchange', () => { // Подписываемся на изменения якоря в адресе
      handleHashNavigation(); // Переключаем вкладки в зависимости от нового якоря
    }); // Конец обработчика изменения якоря

    renderPeers(initialPeers || []); // Отрисовываем селектор чатов
    renderLogs(initialLogs || [], { append: false }); // Отрисовываем стартовые логи
    serviceTotal = (initialServiceLogs || []).length; // Запоминаем количество стартовых сервисных логов
    servicePageLabel.textContent = serviceTotal ? `Показано ${Math.min(serviceTotal, Number(serviceLimitInput.value) || 50)} из ${serviceTotal}` : 'Нет данных'; // Показываем подпись пагинации
    renderServiceLogs(initialServiceLogs || []); // Отрисовываем стартовые сервисные логи
    window.addEventListener('scroll', handleScrollForLogs); // Подключаем бесконечную прокрутку для логов
    if (hasMoreLogs) { // Если есть данные для дальнейшей загрузки
      loadLogs(); // Запускаем подгрузку следующей страницы
    } // Конец проверки наличия данных
    handleHashNavigation(); // Выбираем нужную вкладку с учетом якоря
  </script> <!-- Конец скрипта -->
</body> <!-- Конец тела -->
</html> <!-- Конец документа -->
