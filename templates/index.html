<!doctype html> <!-- Объявляем тип документа -->
<html lang="ru"> <!-- Указываем язык страницы -->
<head> <!-- Начало заголовка страницы -->
  <meta charset="UTF-8" /> <!-- Кодировка UTF-8 для поддержки русского -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- Масштабирование для мобильных -->
  <title>VK Bot Dashboard</title> <!-- Заголовок вкладки -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" /> <!-- Подключаем Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com" /> <!-- Оптимизируем загрузку шрифта -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> <!-- Разрешаем кросс-доменную загрузку шрифта -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" /> <!-- Подключаем шрифт Inter -->
  <style> /* Начало пользовательских стилей */
    body { background: #0f172a; color: #e2e8f0; font-family: "Inter", system-ui, -apple-system, sans-serif; } /* Фон и текст */
    .glass { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 18px; backdrop-filter: blur(10px); } /* Стиль стекла */
    .hero { background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.1), transparent 35%), radial-gradient(circle at 80% 0%, rgba(94, 234, 212, 0.08), transparent 30%); } /* Подсветка героя */
    .badge-soft { background: rgba(99, 102, 241, 0.15); color: #c7d2fe; border: 1px solid rgba(99, 102, 241, 0.35); } /* Мягкий бейдж */
    .metric { font-size: 32px; font-weight: 700; } /* Размер цифр метрик */
    .metric-sub { color: #94a3b8; font-size: 14px; } /* Подпись метрик */
    .card-title { font-weight: 700; letter-spacing: 0.02em; } /* Заголовок карточек */
    .table > :not(caption) > * > * { background-color: transparent; color: #e2e8f0; } /* Прозрачный фон таблицы */
    .table-striped > tbody > tr:nth-of-type(odd) > * { background: rgba(255, 255, 255, 0.03); } /* Полосатая таблица */
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(148, 163, 184, 0.4); color: #cbd5e1; font-size: 13px; } /* Пилюли статуса */
    .stat-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; } /* Точка индикатора */
    .shadow-soft { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25); } /* Мягкая тень */
    .chart-card { min-height: 320px; } /* Минимальная высота графика для компактности */
    .avatar-inline { width: 1.6em; height: 1.6em; border-radius: 999px; object-fit: cover; flex-shrink: 0; } /* Класс для маленьких аватарок по размеру текста */
    .attachment-pill { display: inline-flex; gap: 6px; align-items: center; padding: 4px 10px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.05); color: #e2e8f0; font-size: 12px; text-decoration: none; } /* Пилюля для вложения */
    .attachment-pill:hover { text-decoration: none; background: rgba(255, 255, 255, 0.08); } /* Подсветка при наведении */
    .attachment-photo { border-color: rgba(59, 130, 246, 0.5); color: #bfdbfe; } /* Цвет для фото */
    .attachment-video { border-color: rgba(244, 114, 182, 0.5); color: #fbcfe8; } /* Цвет для видео */
    .attachment-doc { border-color: rgba(74, 222, 128, 0.5); color: #bbf7d0; } /* Цвет для документов */
    .attachment-audio { border-color: rgba(56, 189, 248, 0.5); color: #bae6fd; } /* Цвет для аудио */
    .attachment-sticker { border-color: rgba(248, 180, 0, 0.6); color: #fef08a; } /* Цвет для стикеров */
    .attachment-wall { border-color: rgba(236, 72, 153, 0.6); color: #fbcfe8; } /* Цвет для постов */
    .attachment-link { border-color: rgba(14, 165, 233, 0.5); color: #bae6fd; } /* Цвет для ссылок */
    .attachment-generic { border-color: rgba(148, 163, 184, 0.5); color: #e2e8f0; } /* Цвет для прочего */
    .attachment-group { display: flex; flex-wrap: wrap; gap: 6px; } /* Группа вложений */
    .copy-block { display: flex; flex-direction: column; gap: 4px; padding: 6px 10px; border-radius: 12px; border: 1px dashed rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.02); } /* Карточка репоста */
    .copy-header { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cbd5e1; } /* Заголовок репоста */
    .copy-attachments { display: flex; flex-wrap: wrap; gap: 6px; } /* Блок вложений внутри репоста */
    .content-cell { display: flex; flex-direction: column; gap: 6px; } /* Ячейка таблицы для контента */
    .gallery-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 16px; } /* Затемненный фон галереи */
    .gallery-body { background: #0b1220; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; max-width: 900px; width: 100%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35); display: flex; flex-direction: column; gap: 12px; padding: 16px; } /* Контейнер галереи */
    .gallery-media { position: relative; min-height: 320px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.03); border-radius: 12px; overflow: hidden; } /* Блок медиа */
    .gallery-media img, .gallery-media video { max-height: 540px; width: 100%; object-fit: contain; border-radius: 12px; background: #0b1220; } /* Медиа внутри галереи */
    .gallery-actions { display: flex; align-items: center; justify-content: space-between; gap: 12px; } /* Кнопки управления */
    .gallery-meta { display: flex; flex-direction: column; gap: 4px; font-size: 14px; color: #cbd5e1; } /* Блок описания контента */
    .gallery-nav-btn { min-width: 42px; } /* Минимальная ширина кнопок навигации */
    .gallery-thumb { margin: 2px; } /* Отступы кнопок миниатюр */
    .gallery-thumb.active { border-width: 2px !important; } /* Подсветка активного вложения */
  </style> <!-- Конец пользовательских стилей -->
</head> <!-- Конец заголовка -->
<body class="pb-5"> <!-- Тело страницы с нижним отступом -->
  <div class="container-fluid py-4"> <!-- Контейнер на всю ширину страницы -->
    <div class="p-4 p-md-5 mb-4 hero glass shadow-soft"> <!-- Блок героя -->
      <div class="d-flex align-items-center justify-content-between flex-wrap gap-3"> <!-- Верхняя строка героя -->
        <div> <!-- Левая часть -->
          <div class="d-inline-flex align-items-center gap-2 mb-2"> <!-- Бейджи статуса -->
            <span class="pill"> <!-- Пилюля статуса -->
              <span class="stat-dot bg-info"></span> <!-- Точка состояния -->
              Мониторинг активен <!-- Текст статуса -->
            </span> <!-- Конец пилюли -->
            <span class="pill" id="demo-badge" style="display: none;"> <!-- Пилюля демо -->
              <span class="stat-dot bg-warning"></span> <!-- Точка демо -->
              Демо-режим <!-- Подпись демо -->
            </span> <!-- Конец пилюли демо -->
          </div> <!-- Конец блока бейджей -->
          <h1 class="fw-bold mb-2">Дашборд VK-бота</h1> <!-- Заголовок героя -->
          <p class="text-secondary mb-0">Живые метрики лонгпулла, графики и последние сообщения без отправки от лица сообщества.</p> <!-- Подзаголовок -->
        </div> <!-- Конец левой части -->
        <div class="text-end"> <!-- Правая часть -->
          <div class="card glass shadow-soft px-4 py-3"> <!-- Карточка информации -->
            <div class="text-secondary small">Сообщество</div> <!-- Подпись -->
            <div class="fw-semibold text-light" id="group-name">—</div> <!-- Имя сообщества с более контрастным цветом -->
            <div class="text-secondary small" id="group-id">—</div> <!-- ID или адрес -->
            <div class="text-secondary small" id="group-members">—</div> <!-- Количество участников -->
          </div> <!-- Конец карточки -->
        </div> <!-- Конец правой части -->
      </div> <!-- Конец верхней строки героя -->
    </div> <!-- Конец героя -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок важных сообщений -->
      <div class="d-flex flex-wrap align-items-center justify-content-between gap-3"> <!-- Контейнер заголовка -->
        <div> <!-- Левая часть блока -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Здесь появляются критичные сигналы от сервиса">Важные сообщения</div> <!-- Заголовок блока с подсказкой -->
          <div class="text-secondary small">Ошибки и предупреждения сервисных процессов.</div> <!-- Подпись -->
        </div> <!-- Конец левой части -->
        <div class="d-flex align-items-center gap-2"> <!-- Правая часть -->
          <span id="important-badge" class="badge bg-danger fs-6">0</span> <!-- Бейдж количества -->
          <a href="/logs/full#service-alerts" class="btn btn-outline-light btn-sm">Перейти к оповещениям</a> <!-- Кнопка перехода -->
        </div> <!-- Конец правой части -->
      </div> <!-- Конец контейнера -->
    </div> <!-- Конец блока важных сообщений -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок выбора чата -->
      <div class="d-flex flex-column flex-lg-row align-items-lg-center justify-content-between gap-3"> <!-- Контейнер -->
        <div> <!-- Левая колонка -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Настройте, из каких чатов получать логи">Источник данных</div> <!-- Заголовок с подсказкой -->
          <div class="text-secondary small">Выберите конкретный peer_id или смотрите сразу все сообщения.</div> <!-- Подпись -->
        </div> <!-- Конец левой колонки -->
        <div class="d-flex flex-column flex-md-row gap-2 align-items-md-center"> <!-- Контейнер селектора -->
          <label class="text-secondary small mb-0" for="peer-select">Фильтр по чату</label> <!-- Подпись селектора -->
          <select id="peer-select" class="form-select bg-dark text-light border-secondary" style="min-width: 240px"> <!-- Селектор чатов -->
            <option value="">Все чаты</option> <!-- Опция по умолчанию -->
          </select> <!-- Конец селектора -->
        </div> <!-- Конец контейнера селектора -->
      </div> <!-- Конец контейнера -->
    </div> <!-- Конец блока выбора чата -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок информации о файле базы -->
      <div class="d-flex flex-column flex-lg-row align-items-lg-center justify-content-between gap-3"> <!-- Контейнер -->
        <div> <!-- Левая колонка -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Локальный файл, куда пишутся все события бота">Файл логов событий</div> <!-- Заголовок с подсказкой -->
          <div class="text-secondary small">Файл автоматически создается рядом с проектом и пополняется при каждом событии.</div> <!-- Подпись -->
        </div> <!-- Конец левой колонки -->
        <div class="text-secondary small"> <!-- Правая колонка -->
          <div><span class="text-light">Путь:</span> <span id="storage-path">—</span></div> <!-- Строка пути -->
          <div><span class="text-light">Размер:</span> <span id="storage-size">—</span></div> <!-- Строка размера -->
          <div><span class="text-light">Статус:</span> <span id="storage-status">—</span></div> <!-- Строка статуса -->
        </div> <!-- Конец правой колонки -->
      </div> <!-- Конец контейнера -->
    </div> <!-- Конец блока информации о файле базы -->

    <div class="row g-4 mb-4"> <!-- Строка метрик -->
      <div class="col-12 col-lg-6"> <!-- Колонка активных участников -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка -->
            <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок карточки -->
              <div class="card-title" data-bs-toggle="tooltip" title="Сколько уникальных людей активно взаимодействуют">Активные участники</div> <!-- Текст с подсказкой -->
              <span class="badge-soft badge rounded-pill">Live</span> <!-- Бейдж -->
            </div> <!-- Конец заголовка -->
            <div class="metric" id="active-members-count">0</div> <!-- Число активных участников -->
          <div class="metric-sub">За последние события</div> <!-- Подпись -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
      <div class="col-12 col-lg-6"> <!-- Колонка сообщений -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка -->
            <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок карточки -->
              <div class="card-title" data-bs-toggle="tooltip" title="Количество входящих сообщений">Сообщения</div> <!-- Текст с подсказкой -->
              <span class="badge bg-info text-dark">Входящие</span> <!-- Бейдж -->
            </div> <!-- Конец заголовка -->
            <div class="metric" id="messages-count">0</div> <!-- Число сообщений -->
          <div class="metric-sub">Новые за сессию</div> <!-- Подпись -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
    </div> <!-- Конец строки метрик -->
    <div class="row g-4 mb-4"> <!-- Строка с графиком и диалогами -->
      <div class="col-12 col-xl-6"> <!-- Колонка с графиком -->
        <div class="glass p-4 shadow-soft chart-card"> <!-- Карточка графика -->
          <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <!-- Заголовок графика -->
            <div> <!-- Левая часть заголовка графика -->
              <div class="card-title mb-1" data-bs-toggle="tooltip" title="График активности участников и новых сообщений">Динамика активности</div> <!-- Название с подсказкой -->
              <div class="text-secondary small">Обновляется каждые 3 секунды</div> <!-- Подпись -->
            </div> <!-- Конец левой части заголовка графика -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер для селектора диапазона и статуса -->
              <select class="form-select form-select-sm bg-dark text-light" id="time-range-select"> <!-- Селектор временного диапазона -->
                <option value="15">15 минут</option> <!-- Опция 15 минут -->
                <option value="60">1 час</option> <!-- Опция 1 час -->
                <option value="360">6 часов</option> <!-- Опция 6 часов -->
                <option value="1440">24 часа</option> <!-- Опция 24 часа -->
              </select> <!-- Конец селектора -->
              <span class="pill"> <!-- Индикатор статуса лонгпулла -->
                <span class="stat-dot bg-info"></span> <!-- Точка -->
                Лонгпулл активен <!-- Подпись -->
              </span> <!-- Конец индикатора -->
            </div> <!-- Конец контейнера -->
          </div> <!-- Конец заголовка -->
          <canvas id="events-chart" height="260"></canvas> <!-- Полотно графика -->
        </div> <!-- Конец карточки графика -->
      </div> <!-- Конец колонки графика -->
      <div class="col-12 col-xl-6"> <!-- Колонка диалогов -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка диалогов -->
          <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок -->
            <div class="card-title mb-1" data-bs-toggle="tooltip" title="Список диалогов, доступных боту">Диалоги и чаты</div> <!-- Название с подсказкой -->
            <span class="badge bg-secondary">Read-only</span> <!-- Бейдж -->
          </div> <!-- Конец заголовка -->
          <div class="table-responsive"> <!-- Обертка таблицы -->
            <table class="table table-striped align-middle mb-0"> <!-- Таблица диалогов -->
              <thead class="text-secondary"> <!-- Заголовок -->
                <tr> <!-- Строка заголовка таблицы -->
                  <th>peer_id</th> <!-- Заголовок идентификатора чата -->
                  <th>Тип</th> <!-- Заголовок типа диалога -->
                  <th>Название</th> <!-- Заголовок названия чата -->
                  <th>Сообщений</th> <!-- Заголовок количества сообщений -->
                </tr> <!-- Конец строки заголовка таблицы -->
              </thead> <!-- Конец заголовка таблицы -->
              <tbody id="conversations-body"> <!-- Тело -->
                <tr> <!-- Строка-заглушка диалогов -->
                  <td colspan="4" class="text-secondary">Нет данных</td> <!-- Плейсхолдер -->
                </tr> <!-- Конец строки-заглушки диалогов -->
              </tbody> <!-- Конец тела таблицы -->
            </table> <!-- Конец таблицы -->
          </div> <!-- Конец обертки -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
    </div> <!-- Конец строки с графиком и диалогами -->

    <div class="row g-4"> <!-- Строка для последних сообщений в самом низу -->
      <div class="col-12"> <!-- Единственная колонка на всю ширину -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка сообщений -->
          <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок -->
            <div> <!-- Левая часть заголовка -->
              <div class="card-title mb-1" data-bs-toggle="tooltip" title="Свежие сообщения с сортировкой сверху вниз">Последние сообщения</div> <!-- Название с подсказкой -->
              <div class="text-secondary small">Новые сверху, без технических ID — только понятные подписи</div> <!-- Подпись с уточнением ширины -->
            </div> <!-- Конец левой части заголовка -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер кнопок -->
              <span class="badge-soft badge rounded-pill" id="timezone-badge" title="">Локальное время</span> <!-- Бейдж с подсказкой о часовом поясе -->
              <span class="badge-soft badge rounded-pill">READ ONLY</span> <!-- Бейдж readonly -->
              <a href="/logs/full" class="btn btn-outline-light btn-sm"> <!-- Кнопка просмотра всех сообщений -->
                Посмотреть все <!-- Текст кнопки -->
              </a> <!-- Конец кнопки -->
            </div> <!-- Конец контейнера кнопок -->
          </div> <!-- Конец заголовка -->
          <div class="table-responsive"> <!-- Обертка таблицы -->
            <table class="table table-sm table-striped align-middle mb-0"> <!-- Таблица сообщений -->
              <thead class="text-secondary"> <!-- Заголовок таблицы -->
                <tr> <!-- Строка заголовка -->
                  <th>Чат</th> <!-- Заголовок столбца -->
                  <th>Отправитель</th> <!-- Заголовок столбца с человеком или ботом -->
                  <th>Ответ</th> <!-- Заголовок столбца -->
                  <th>Вложения</th> <!-- Заголовок столбца -->
                  <th>Текст</th> <!-- Заголовок столбца -->
                </tr> <!-- Конец строки заголовка -->
              </thead> <!-- Конец заголовка таблицы -->
              <tbody id="messages-body"> <!-- Тело таблицы -->
                <tr> <!-- Строка-заглушка -->
                  <td colspan="5" class="text-secondary">Нет данных</td> <!-- Плейсхолдер -->
                </tr> <!-- Конец строки-заглушки -->
              </tbody> <!-- Конец тела таблицы -->
            </table> <!-- Конец таблицы -->
          </div> <!-- Конец обертки таблицы -->
        </div> <!-- Конец карточки сообщений -->
      </div> <!-- Конец единственной колонки -->
    </div> <!-- Конец строки для сообщений -->
  </div> <!-- Конец контейнера -->

  <div id="gallery-modal" class="gallery-backdrop"> <!-- Фон модального окна галереи -->
    <div class="gallery-body"> <!-- Тело модального окна -->
      <div class="d-flex justify-content-between align-items-center"> <!-- Шапка модалки -->
        <div class="fw-semibold">Просмотр вложений</div> <!-- Заголовок модалки -->
        <button type="button" class="btn btn-outline-light btn-sm" id="gallery-close">Закрыть</button> <!-- Кнопка закрытия -->
      </div> <!-- Конец шапки -->
      <div id="gallery-strip" class="attachment-group flex-wrap"> <!-- Полоса миниатюр вложений -->
        <span class="text-secondary small">Здесь появятся все вложения сообщения</span> <!-- Плейсхолдер полосы миниатюр -->
      </div> <!-- Конец полосы миниатюр -->
      <div class="gallery-media" id="gallery-media"> <!-- Блок медиа внутри галереи -->
        <div class="text-secondary">Нет выбранного вложения</div> <!-- Плейсхолдер, если нет данных -->
      </div> <!-- Конец блока медиа -->
      <div class="gallery-actions"> <!-- Панель управления галереей -->
        <button type="button" class="btn btn-outline-light gallery-nav-btn" id="gallery-prev">←</button> <!-- Кнопка предыдущего элемента -->
        <div class="gallery-meta"> <!-- Описание текущего вложения -->
          <div id="gallery-caption" class="text-light">—</div> <!-- Подпись файла -->
          <div id="gallery-origin" class="text-secondary">Источник неизвестен</div> <!-- Источник файла -->
          <div id="gallery-links" class="small">—</div> <!-- Ссылки и действия -->
        </div> <!-- Конец описания -->
        <button type="button" class="btn btn-outline-light gallery-nav-btn" id="gallery-next">→</button> <!-- Кнопка следующего элемента -->
      </div> <!-- Конец панели управления -->
    </div> <!-- Конец тела модалки -->
  </div> <!-- Конец фона модального окна -->

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> <!-- Подключаем Bootstrap JS для тултипов -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> <!-- Подключаем Chart.js -->
  <script> // Начало скрипта
    const initialStats = {{ initial_stats|tojson }}; // Читаем стартовые метрики из шаблона без ручного парсинга, чтобы не было ошибок на кавычках
    const initialGroup = {{ initial_group|tojson }}; // Читаем информацию о сообществе в безопасном виде
    const initialConversations = {{ initial_conversations|tojson }}; // Читаем список диалогов без риска испортить JSON
    const initialPeers = {{ initial_peers|tojson }}; // Читаем стартовый список peer_id без ошибок экранирования
    const initialStorage = {{ initial_storage|tojson }}; // Читаем стартовую информацию о файле базы
    const demoMode = {{ 'true' if demo_mode else 'false' }}; // Флаг демо-режима

    const activeMembersEl = document.getElementById('active-members-count'); // Находим элемент активных участников
    const messagesEl = document.getElementById('messages-count'); // Находим элемент сообщений
    const messagesBody = document.getElementById('messages-body'); // Тело таблицы сообщений
    const conversationsBody = document.getElementById('conversations-body'); // Тело таблицы диалогов
    const groupNameEl = document.getElementById('group-name'); // Заголовок сообщества
    const groupIdEl = document.getElementById('group-id'); // ID сообщества
    const groupMembersEl = document.getElementById('group-members'); // Количество участников
    const demoBadge = document.getElementById('demo-badge'); // Бейдж демо
    const peerSelect = document.getElementById('peer-select'); // Селектор чатов
    const storagePathEl = document.getElementById('storage-path'); // Путь до файла базы
    const storageSizeEl = document.getElementById('storage-size'); // Размер файла базы
    const storageStatusEl = document.getElementById('storage-status'); // Статус существования файла
    const importantBadge = document.getElementById('important-badge'); // Бейдж важных оповещений
    const timeRangeSelect = document.getElementById('time-range-select'); // Селектор выбора диапазона времени
    const galleryModal = document.getElementById('gallery-modal'); // Контейнер модалки галереи
    const galleryMedia = document.getElementById('gallery-media'); // Блок, где показываем медиа
    const galleryStrip = document.getElementById('gallery-strip'); // Полоса миниатюр для всех вложений
    const galleryCaption = document.getElementById('gallery-caption'); // Подпись текущего файла
    const galleryOrigin = document.getElementById('gallery-origin'); // Источник файла
    const galleryLinks = document.getElementById('gallery-links'); // Блок ссылок и действий
    const galleryClose = document.getElementById('gallery-close'); // Кнопка закрытия галереи
    const galleryPrev = document.getElementById('gallery-prev'); // Кнопка предыдущего вложения
    const galleryNext = document.getElementById('gallery-next'); // Кнопка следующего вложения
    const galleryStore = {}; // Хранилище списков вложений по сообщениям
    let currentGalleryKey = null; // Текущий ключ галереи
    let currentGalleryIndex = 0; // Текущий индекс выбранного вложения
    let galleryCounter = 0; // Счетчик для генерации уникальных ключей галерей
    let currentPeer = ''; // Текущий выбранный peer_id
    let selectedRange = Number(initialStats?.range_minutes ?? 60); // Текущий выбранный диапазон минут

    function resetGalleryStorePreserveActive() { // Очищаем хранилище галерей, сохраняя открытую
      const modalOpen = galleryModal.style.display === 'flex'; // Проверяем, открыта ли модалка
      const preservedKey = modalOpen ? currentGalleryKey : null; // Запоминаем активный ключ
      const preservedValue = preservedKey ? galleryStore[preservedKey] : null; // Забираем активную галерею
      Object.keys(galleryStore).forEach((key) => { // Перебираем все ключи
        if (!preservedKey || key !== preservedKey) { // Если ключ не активный
          delete galleryStore[key]; // Удаляем из хранилища
        } // Конец проверки ключа
      }); // Конец очистки
      if (preservedKey && preservedValue) { // Если есть активная галерея
        galleryStore[preservedKey] = preservedValue; // Возвращаем её обратно
      } // Конец восстановления
    } // Конец функции сохранения открытой галереи

    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions(); // Считываем параметры локальной таймзоны браузера
    const timezoneOffsetMinutes = new Date().getTimezoneOffset(); // Получаем смещение от UTC в минутах
    const timezoneOffsetSign = timezoneOffsetMinutes <= 0 ? '+' : '-'; // Определяем знак смещения
    const timezoneOffsetHours = String(Math.floor(Math.abs(timezoneOffsetMinutes) / 60)).padStart(2, '0'); // Вычисляем часы смещения с ведущим нулем
    const timezoneOffsetRestMinutes = String(Math.abs(timezoneOffsetMinutes) % 60).padStart(2, '0'); // Вычисляем минуты смещения с ведущим нулем
    const timezoneLabel = `UTC${timezoneOffsetSign}${timezoneOffsetHours}:${timezoneOffsetRestMinutes} (${timezoneInfo.timeZone || 'локальное время'})`; // Формируем подпись таймзоны и смещения
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: timezoneInfo.timeZone, timeZoneName: 'short' }); // Настраиваем формат вывода времени

    document.getElementById('timezone-badge').title = `Отображается время ${timezoneLabel}`; // Обновляем подсказку бейджа таймзоны

    const tooltipTriggerList = Array.from(document.querySelectorAll('[data-bs-toggle="tooltip"]')); // Собираем все элементы, на которых нужно активировать тултипы
    tooltipTriggerList.forEach((triggerEl) => new bootstrap.Tooltip(triggerEl)); // Инициализируем Bootstrap тултипы для каждого элемента

    if (timeRangeSelect) { // Если селектор диапазона найден
      timeRangeSelect.value = String(selectedRange); // Устанавливаем текущее значение из стартовых данных
      timeRangeSelect.addEventListener('change', () => { // Подписываемся на изменение диапазона
        selectedRange = Number(timeRangeSelect.value || 60); // Обновляем выбранный диапазон
        poll(); // Запускаем немедленное обновление данных
      }); // Конец обработчика изменения
    } // Конец проверки селектора

    function formatDateTime(value) { // Функция форматирования даты
      const parsed = value ? new Date(value) : null; // Создаем объект даты при наличии значения
      return parsed && !Number.isNaN(parsed.valueOf()) ? timeFormatter.format(parsed) : '—'; // Возвращаем отформатированную строку или тире
    } // Конец функции форматирования

    if (demoMode) { // Если включен демо-режим
      demoBadge.style.display = 'inline-flex'; // Показываем бейдж демо
    } // Конец условия демо

    const ctx = document.getElementById('events-chart'); // Получаем холст графика
    const chart = new Chart(ctx, { // Создаем график
      type: 'line', // Тип графика
      data: { // Данные графика
        labels: initialStats.timeline.map((p) => formatDateTime(p.time)), // Метки времени в локальном формате
        datasets: [ // Наборы данных
          { label: 'Активные участники', data: initialStats.timeline.map((p) => p.invites), borderColor: '#fbbf24', backgroundColor: 'rgba(251,191,36,0.25)', tension: 0.3, fill: true }, // Линия активных участников
          { label: 'Сообщения', data: initialStats.timeline.map((p) => p.messages), borderColor: '#34d399', backgroundColor: 'rgba(52,211,153,0.25)', tension: 0.3, fill: true }, // Линия сообщений
        ], // Конец наборов
      }, // Конец данных
      options: { // Настройки графика
        plugins: { legend: { labels: { color: '#cbd5e1' } } }, // Цвет легенды
        scales: { // Настройки осей
          x: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.04)' } }, // Ось X
          y: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.04)' } }, // Ось Y
        }, // Конец осей
      }, // Конец настроек
    }); // Конец создания графика

    function renderGroup(data) { // Функция вывода информации о сообществе
      groupNameEl.textContent = data.name || '—'; // Отображаем название
      groupIdEl.textContent = data.screen_name ? `vk.com/${data.screen_name}` : 'ID: ' + (data.id || '—'); // Отображаем адрес
      groupMembersEl.textContent = data.members_count ? `${data.members_count} участников` : 'Участники: —'; // Отображаем участников
    } // Конец функции

    function buildAvatarLabel(label, avatarUrl) { // Функция построения подписи с аватаркой
      const safeLabel = label || '—'; // Определяем подпись, если значения нет
      if (avatarUrl) { // Если есть ссылка на аватар
        return `<span class="d-inline-flex align-items-center gap-2"><img src="${avatarUrl}" alt="Аватар" class="avatar-inline" loading="lazy" /> <span>${safeLabel}</span></span>`; // Возвращаем подпись с картинкой
      } // Конец проверки аватара
      return safeLabel; // Если аватар отсутствует, возвращаем только текст
    } // Конец функции построения подписи

    function buildReplyPreview(reply) { // Функция сборки ячейки ответа без технических ID
      if (!reply || (!reply.id && !reply.text && !reply.from_id)) { // Проверяем наличие полезных данных
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер при отсутствии ответа
      } // Конец проверки наличия ответа
      const replyText = reply.text ? reply.text.slice(0, 120) : 'Без текста'; // Готовим превью текста ответа
      const replyAuthorName = reply.from_name || 'Автор неизвестен'; // Определяем человека, если есть имя
      const replyAuthorCell = buildAvatarLabel(replyAuthorName, reply.from_avatar); // Готовим подпись автора с аватаркой без ID
      const replyAttachmentsCount = Array.isArray(reply.attachments) ? reply.attachments.length : 0; // Считаем вложения исходного сообщения
      const replyAttachmentsLabel = replyAttachmentsCount ? `${replyAttachmentsCount} влож.` : 'Без вложений'; // Формируем подпись вложений
      return `<div class="d-flex flex-column gap-1"><div class="text-secondary small">Ответ на: ${replyAuthorCell}</div><div class="text-secondary small">${replyText}</div><div class="text-secondary small">${replyAttachmentsLabel}</div></div>`; // Возвращаем HTML ячейки без ссылок и ID
    } // Конец функции сборки ответа

    const attachmentTypeLabels = { photo: 'Фото', video: 'Видео', doc: 'Документ', audio_message: 'Голос', audio: 'Аудио', link: 'Ссылка', sticker: 'Стикер', wall: 'Пост', wall_reply: 'Комментарий', market: 'Товар', gift: 'Подарок', story: 'История', graffiti: 'Граффити', podcast: 'Подкаст', share: 'Репост', file: 'Файл' }; // Человекочитаемые подписи типов вложений
    const attachmentTypeClasses = { photo: 'attachment-photo', video: 'attachment-video', doc: 'attachment-doc', audio: 'attachment-audio', audio_message: 'attachment-audio', link: 'attachment-link', wall: 'attachment-wall', wall_reply: 'attachment-wall', sticker: 'attachment-sticker', default: 'attachment-generic' }; // Классы подсветки для типов

    function normalizeAttachmentLink(att) { // Функция получения ссылки на вложение
      if (!att || typeof att !== 'object') { // Проверяем корректность объекта
        return null; // Возвращаем пустое значение
      } // Конец проверки
      return att.public_url || att.download_url || att.url || null; // Возвращаем найденную ссылку или null
    } // Конец функции

    function isVideoType(type) { // Проверяем, является ли тип видеоконтентом
      return type === 'video' || type === 'story'; // Считаем видео и истории медиаконтентом с плеером
    } // Конец функции определения видео

    function attachmentSignature(att) { // Формируем сигнатуру вложения для устранения дублей
      if (!att || typeof att !== 'object') { // Проверяем корректность данных
        return null; // Возвращаем пустое значение при ошибке
      } // Конец проверки
      const type = att.type || (att.photo ? 'photo' : att.video ? 'video' : att.doc ? 'doc' : null); // Определяем тип вложения
      const nested = type && att[type] && typeof att[type] === 'object' ? att[type] : {}; // Получаем вложенный блок по типу
      const owner = nested.owner_id; // Читаем owner_id вложения
      const id = nested.id; // Читаем id вложения
      const access = nested.access_key; // Читаем access_key вложения
      if (owner !== undefined && id !== undefined) { // Если есть связка owner_id и id
        return `${type}:${owner}_${id}_${access || ''}`; // Возвращаем сигнатуру по ID
      } // Конец проверки идентификаторов
      const url = normalizeAttachmentLink(att) || att.public_url || att.download_url || att.url; // Подбираем ссылку вложения
      if (url) { // Если ссылка существует
        return `${type || 'file'}:${url}`; // Формируем сигнатуру по ссылке
      } // Конец проверки ссылки
      try { // Пытаемся сериализовать объект
        return JSON.stringify(att); // Возвращаем сериализованный объект как сигнатуру
      } catch (e) { // Ловим ошибки сериализации
        return null; // Возвращаем пустое значение при исключении
      } // Конец обработки ошибок
    } // Конец функции формирования сигнатуры

    function collectAttachmentItems(list, origin, bucket, seen) { // Собираем элементы вложений в плоский список галереи
      if (!Array.isArray(list)) { // Проверяем формат входящего списка
        return; // Выходим, если данные некорректны
      } // Конец проверки
      list.forEach((att) => { // Перебираем каждое вложение
        if (!att || typeof att !== 'object') { // Проверяем тип элемента
          return; // Пропускаем неверные записи
        } // Конец проверки типа
        const signature = attachmentSignature(att); // Вычисляем сигнатуру вложения
        if (signature && seen && seen.has(signature)) { // Проверяем, добавляли ли уже это вложение
          return; // Пропускаем дубликат
        } // Конец проверки дубля
        const url = normalizeAttachmentLink(att); // Получаем ссылку на вложение
        if (!url) { // Если ссылки нет
          return; // Пропускаем элемент
        } // Конец проверки наличия ссылки
        const type = att.type || 'file'; // Определяем тип вложения
        const caption = att.title || att.name || att.doc?.title || att.link?.title || att.photo?.text || att.description || ''; // Подбираем подпись вложения
        if (signature && seen) { // Проверяем, что сигнатура рассчитана и есть набор дублей
          seen.add(signature); // Добавляем сигнатуру в набор
        } // Конец добавления сигнатуры
        bucket.push({ url, type, caption, origin: origin || 'Сообщение' }); // Добавляем элемент в галерею
      }); // Конец перебора вложений
    } // Конец функции сборки вложений

    function mergeAttachmentLists(primary, fallback) { // Объединяем вложения из основного блока и payload без дублей
      const result = []; // Итоговый массив объединенных вложений
      const seen = new Set(); // Набор ключей для устранения дублей
      const pushUnique = (item) => { // Вспомогательная функция добавления элемента
        if (!item || typeof item !== 'object') { // Проверяем корректность вложения
          return; // Пропускаем некорректные элементы
        } // Конец проверки
        const signature = attachmentSignature(item); // Формируем сигнатуру вложения
        if (signature && seen.has(signature)) { // Проверяем, был ли элемент уже добавлен
          return; // Пропускаем дубликат
        } // Конец проверки дубля
        if (signature) { // Если сигнатура рассчитана
          seen.add(signature); // Добавляем сигнатуру в набор
        } // Конец добавления сигнатуры
        result.push(item); // Кладем вложение в итоговый список
      }; // Конец вспомогательной функции
      if (Array.isArray(primary)) { // Проверяем основной список вложений
        primary.forEach(pushUnique); // Добавляем каждый элемент из основного списка
      } // Конец проверки основного списка
      if (Array.isArray(fallback)) { // Проверяем запасной список из payload
        fallback.forEach(pushUnique); // Добавляем вложения из payload
      } // Конец проверки fallback
      return result; // Возвращаем объединенный список
    } // Конец функции объединения списков вложений

    function extractAttachments(message) { // Извлекаем и объединяем вложения из основного блока и payload
      const primary = Array.isArray(message?.attachments) ? message.attachments : []; // Забираем вложения сообщения
      const fallback = message?.payload && Array.isArray(message.payload.attachments) ? message.payload.attachments : []; // Забираем вложения из payload
      return mergeAttachmentLists(primary, fallback); // Возвращаем объединенный список без дублей
    } // Конец функции извлечения вложений

    function extractCopyHistory(message) { // Извлекаем copy_history из сообщения или payload
      const primary = Array.isArray(message?.copy_history) ? message.copy_history : []; // Основной список репостов
      const fallback = message?.payload && Array.isArray(message.payload.copy_history) ? message.payload.copy_history : []; // Запасной список из payload
      return [...primary, ...fallback].filter((entry) => entry && typeof entry === 'object'); // Объединяем списки и фильтруем корректные объекты
    } // Конец функции извлечения copy_history

    function countAttachmentList(list) { // Считает количество вложений в списке
      if (!Array.isArray(list)) { // Проверяем формат
        return 0; // Возвращаем ноль при ошибке
      } // Конец проверки
      return list.filter((item) => item && typeof item === 'object').length; // Считаем только объекты вложений
    } // Конец функции подсчета вложений

    function countCopyHistoryAttachments(entries) { // Рекурсивно считает вложения в copy_history
      if (!Array.isArray(entries)) { // Проверяем формат входных данных
        return 0; // Возвращаем ноль при ошибке
      } // Конец проверки
      return entries.reduce((acc, entry) => { // Накопительно обрабатываем репосты
        if (!entry || typeof entry !== 'object') { // Проверяем тип элемента
          return acc; // Возвращаем текущий счетчик без изменений
        } // Конец проверки
        const selfCount = countAttachmentList(entry.attachments); // Считаем вложения самого репоста
        const nestedCount = countCopyHistoryAttachments(entry.copy_history); // Считаем вложения вложенных репостов
        return acc + selfCount + nestedCount; // Складываем результаты
      }, 0); // Начальное значение счетчика ноль
    } // Конец функции рекурсивного подсчета

    function findFirstAttachmentLink(list) { // Ищем первую ссылку вложения в списке
      if (!Array.isArray(list)) { // Проверяем формат
        return null; // Возвращаем null при ошибке
      } // Конец проверки
      for (const att of list) { // Перебираем вложения
        const link = normalizeAttachmentLink(att); // Получаем ссылку на вложение
        if (link) { // Если ссылка найдена
          return link; // Возвращаем найденную ссылку
        } // Конец проверки
      } // Конец цикла
      return null; // Возвращаем null, если ссылок нет
    } // Конец функции поиска ссылки

    function findFirstCopyHistoryLink(entries) { // Рекурсивно ищем первую ссылку во вложениях copy_history
      if (!Array.isArray(entries)) { // Проверяем формат copy_history
        return null; // Возвращаем null при ошибке
      } // Конец проверки
      for (const entry of entries) { // Перебираем репосты
        if (!entry || typeof entry !== 'object') { // Проверяем тип записи
          continue; // Пропускаем некорректные элементы
        } // Конец проверки
        const direct = findFirstAttachmentLink(entry.attachments); // Пытаемся найти ссылку в вложениях репоста
        if (direct) { // Если ссылка найдена
          return direct; // Возвращаем ссылку
        } // Конец проверки
        const nested = findFirstCopyHistoryLink(entry.copy_history); // Ищем ссылку во вложенных репостах
        if (nested) { // Если ссылка найдена
          return nested; // Возвращаем найденную ссылку
        } // Конец проверки
      } // Конец цикла по репостам
      return null; // Возвращаем null, если ссылок не нашли
    } // Конец функции поиска ссылки в copy_history

    function collectCopyHistoryItems(entries, origin, bucket, seen) { // Рекурсивно собираем вложения из репостов
      if (!Array.isArray(entries)) { // Проверяем формат
        return; // Выходим при ошибке формата
      } // Конец проверки
      entries.forEach((entry) => { // Перебираем каждый репост
        if (!entry || typeof entry !== 'object') { // Проверяем тип
          return; // Пропускаем некорректные данные
        } // Конец проверки типа
        const entryOrigin = entry.from_name ? `Репост от ${entry.from_name}` : origin || 'Репост'; // Формируем подпись источника
        collectAttachmentItems(entry.attachments || [], entryOrigin, bucket, seen); // Собираем вложения репоста без дублей
        if (Array.isArray(entry.copy_history) && entry.copy_history.length) { // Проверяем вложенные репосты
          collectCopyHistoryItems(entry.copy_history, entryOrigin, bucket, seen); // Рекурсивно собираем вложения без дублей
        } // Конец проверки вложенных репостов
      }); // Конец перебора репостов
    } // Конец функции сбора вложений из copy_history

    function registerGallery(message, galleryKey) { // Регистрируем список вложений для галереи
      if (!galleryKey) { // Проверяем, передан ли ключ
        return; // Выходим, если ключа нет
      } // Конец проверки ключа
      const bucket = []; // Готовим список собранных вложений
      const seen = new Set(); // Готовим набор сигнатур для устранения дублей
      const authorLabel = message.from_name ? `${message.from_name} (ID: ${message.from_id ?? '—'})` : `ID: ${message.from_id ?? '—'}`; // Формируем подпись автора
      const peerLabel = message.peer_title ? `${message.peer_title} (ID: ${message.peer_id ?? '—'})` : `ID: ${message.peer_id ?? '—'}`; // Формируем подпись чата
      const meta = { // Готовим описание для подвала галереи
        author: authorLabel, // Автор сообщения
        peer: peerLabel, // Чат, где опубликовано
        text: message.text || 'Без текста', // Текст сообщения
      }; // Конец блока метаданных
      const attachments = extractAttachments(message); // Забираем вложения из сообщения или payload
      const copyHistory = extractCopyHistory(message); // Забираем репосты из сообщения или payload
      collectAttachmentItems(attachments, 'Сообщение', bucket, seen); // Собираем вложения сообщения без дублей
      collectCopyHistoryItems(copyHistory, 'Репост', bucket, seen); // Собираем вложения из репостов без дублей
      if (bucket.length === 0) { // Если вложений нет
        return; // Не сохраняем пустую галерею
      } // Конец проверки пустого списка
      galleryStore[galleryKey] = { items: bucket, meta }; // Сохраняем список и метаданные в хранилище
    } // Конец регистрации галереи

    function pickAttachmentClass(type) { // Функция выбора CSS-класса для типа
      if (!type) { // Проверяем наличие типа
        return attachmentTypeClasses.default; // Возвращаем класс по умолчанию
      } // Конец проверки
      return attachmentTypeClasses[type] || attachmentTypeClasses.default; // Возвращаем подходящий класс или запасной
    } // Конец функции

    function buildAttachmentBadge(att, galleryKey, originLabel) { // Функция сборки HTML для одного вложения
      const type = att?.type || 'file'; // Определяем тип вложения
      const readableType = attachmentTypeLabels[type] || type; // Получаем подпись типа
      const href = normalizeAttachmentLink(att); // Получаем ссылку для открытия
      const caption = att?.title || att?.name || att?.doc?.title || att?.link?.title || att?.photo?.text || att?.description || ''; // Подбираем подпись
      const shortCaption = caption ? caption.slice(0, 60) : ''; // Обрезаем подпись до 60 символов
      const className = pickAttachmentClass(type); // Выбираем класс для подсветки
      const text = shortCaption ? `${readableType}: ${shortCaption}` : readableType; // Формируем текст бейджа
      const originAttr = originLabel ? ` data-gallery-origin="${originLabel}"` : ''; // Готовим атрибут источника для клика
      if (href) { // Если есть ссылка для открытия
        return `<a class="attachment-pill ${className}" href="${href}" data-gallery-key="${galleryKey}"${originAttr} data-gallery-url="${href}" target="_blank" rel="noopener noreferrer">${text}</a>`; // Возвращаем кликабельный бейдж
      } // Конец проверки
      return `<span class="attachment-pill ${className}" data-gallery-key="${galleryKey}"${originAttr}>${text}</span>`; // Возвращаем статичный бейдж, если ссылки нет
    } // Конец функции

    function renderAttachmentList(list, galleryKey, originLabel) { // Функция рендера группы вложений
      if (!Array.isArray(list) || !list.length) { // Проверяем наличие вложений
        return '<span class="text-secondary small">Нет вложений</span>'; // Возвращаем плейсхолдер
      } // Конец проверки
      const badges = list.map((att) => buildAttachmentBadge(att, galleryKey, originLabel)).join(''); // Собираем бейджи
      return `<div class="attachment-group">${badges}</div>`; // Возвращаем контейнер
    } // Конец функции

    function renderCopyHistory(copyHistory, galleryKey) { // Функция рендера репостов и пересланных сообщений
      if (!Array.isArray(copyHistory) || !copyHistory.length) { // Проверяем наличие репостов
        return ''; // Возвращаем пустую строку
      } // Конец проверки
      const blocks = copyHistory.map((entry) => { // Перебираем репосты
        const source = entry.from_name ? `${entry.from_name} (ID: ${entry.from_id ?? '—'})` : `ID: ${entry.from_id ?? '—'}`; // Формируем подпись источника
        const text = entry.text ? entry.text.slice(0, 120) : 'Без текста'; // Формируем превью текста
        const attachmentsBlock = renderAttachmentList(entry.attachments || [], galleryKey, source); // Рисуем вложения репоста
        return `<div class="copy-block"><div class="copy-header">🔁 Репост от ${source}</div><div class="text-secondary small">${text}</div><div class="copy-attachments">${attachmentsBlock}</div></div>`; // Возвращаем блок репоста
      }); // Конец цикла
      return blocks.join(''); // Возвращаем объединенную строку
    } // Конец функции

    function buildAttachmentSummary(attachments, copyHistory, galleryKey) { // Формируем бейдж со скрепкой и количеством
      const attachmentsCount = countAttachmentList(attachments); // Считаем вложения самого сообщения
      const copyCount = countCopyHistoryAttachments(copyHistory); // Считаем вложения в репостах
      const total = attachmentsCount + copyCount; // Подсчитываем итоговое количество
      if (!total) { // Если вложений нет
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер
      } // Конец проверки пустоты
      const previewLink = findFirstAttachmentLink(attachments) || findFirstCopyHistoryLink(copyHistory); // Ищем ссылку первого вложения для открытия
      const className = pickAttachmentClass(total === 1 ? (attachments?.[0]?.type || 'file') : 'file'); // Определяем класс бейджа
      const label = `📎 Скрепка (${total})`; // Формируем текст бейджа
      if (previewLink) { // Если удалось найти ссылку
        return `<a class="attachment-pill ${className}" href="${previewLink}" data-gallery-key="${galleryKey}" data-gallery-url="${previewLink}" target="_blank" rel="noopener noreferrer">${label}</a>`; // Возвращаем кликабельный бейдж
      } // Конец проверки ссылки
      return `<span class="attachment-pill ${className}" data-gallery-key="${galleryKey}">${label}</span>`; // Возвращаем некликабельный бейдж
    } // Конец функции формирования скрепки

    function buildContentCell(attachments, copyHistory, galleryKey) { // Функция сборки ячейки контента
      const hasAttachments = Array.isArray(attachments) && attachments.length > 0; // Проверяем наличие вложений
      const hasCopy = Array.isArray(copyHistory) && copyHistory.length > 0; // Проверяем наличие репостов
      if (!hasAttachments && !hasCopy) { // Если нет ни вложений, ни репостов
        return '<span class="text-secondary">—</span>'; // Возвращаем плейсхолдер
      } // Конец условия
      const summary = buildAttachmentSummary(attachments, copyHistory, galleryKey); // Строим бейдж со скрепкой и количеством
      const copyBlock = hasCopy ? renderCopyHistory(copyHistory, galleryKey) : ''; // Готовим блок репостов
      return `<div class="content-cell">${summary}${copyBlock}</div>`; // Собираем итоговую ячейку
    } // Конец функции

    function renderGalleryStrip(galleryData) { // Рисуем полосу миниатюр
      if (!galleryData || !Array.isArray(galleryData.items) || galleryData.items.length === 0) { // Проверяем входные данные
        galleryStrip.innerHTML = '<span class="text-secondary small">Вложений нет</span>'; // Показываем плейсхолдер
        return; // Выходим при отсутствии данных
      } // Конец проверки
      const buttons = galleryData.items.map((item, idx) => { // Формируем кнопки для каждого вложения
        const typeLabel = attachmentTypeLabels[item.type] || 'Файл'; // Определяем подпись типа
        const activeClass = idx === currentGalleryIndex ? 'active' : ''; // Определяем активный класс
        return `<button type="button" class="btn btn-outline-light btn-sm gallery-thumb ${activeClass}" data-gallery-index="${idx}">${idx + 1}. ${typeLabel}</button>`; // Возвращаем кнопку
      }); // Конец сборки кнопок
      galleryStrip.innerHTML = buttons.join(''); // Рисуем полосу кнопок
    } // Конец функции рендера полосы

    function renderGallerySlide(galleryData, index) { // Рисуем текущий слайд галереи
      if (!galleryData || !Array.isArray(galleryData.items) || !galleryData.items.length) { // Проверяем наличие данных
        galleryMedia.innerHTML = '<div class="text-secondary">Вложений нет</div>'; // Показываем плейсхолдер
        galleryCaption.textContent = '—'; // Сбрасываем подпись
        galleryOrigin.textContent = 'Источник неизвестен'; // Сбрасываем источник
        galleryLinks.innerHTML = '—'; // Сбрасываем ссылки
        return; // Выходим
      } // Конец проверки
      const boundedIndex = Math.max(0, Math.min(index, galleryData.items.length - 1)); // Гарантируем допустимый индекс
      currentGalleryIndex = boundedIndex; // Обновляем текущий индекс
      const item = galleryData.items[boundedIndex]; // Берем выбранный элемент
      const isVideo = isVideoType(item.type); // Проверяем, видео ли это
      const mediaHtml = isVideo ? `<video controls src="${item.url}" class="w-100" preload="metadata"></video>` : `<img src="${item.url}" alt="Вложение" loading="lazy" />`; // Формируем HTML медиа
      galleryMedia.innerHTML = mediaHtml; // Подставляем медиа в модалку
      const caption = item.caption || 'Без описания'; // Подпись файла
      const origin = item.origin || galleryData.meta.peer || 'Источник неизвестен'; // Источник файла
      galleryCaption.textContent = caption; // Обновляем подпись файла
      galleryOrigin.textContent = `${origin} • ${galleryData.meta.peer}`; // Обновляем источник с указанием чата
      const openLink = `<a href="${item.url}" target="_blank" rel="noopener noreferrer">Открыть файл</a>`; // Ссылка на файл
      galleryLinks.innerHTML = `${openLink} · ${galleryData.meta.author}`; // Добавляем ссылку и автора
      renderGalleryStrip(galleryData); // Перерисовываем полосу миниатюр
    } // Конец функции рендера слайда

    function openGallery(key, targetUrl, targetOrigin) { // Открываем модалку галереи
      const galleryData = galleryStore[key]; // Получаем данные галереи
      if (!galleryData || !galleryData.items.length) { // Проверяем наличие контента
        return; // Если данных нет, выходим
      } // Конец проверки
      currentGalleryKey = key; // Сохраняем активный ключ
      let startIndex = 0; // Индекс по умолчанию
      if (targetUrl) { // Если передана целевая ссылка
        const foundIndex = galleryData.items.findIndex((item) => item.url === targetUrl && (!targetOrigin || item.origin === targetOrigin)); // Ищем совпадение
        if (foundIndex >= 0) { // Если совпадение найдено
          startIndex = foundIndex; // Начинаем с нужного элемента
        } // Конец проверки совпадения
      } // Конец проверки целевой ссылки
      renderGallerySlide(galleryData, startIndex); // Рисуем выбранный слайд
      galleryModal.style.display = 'flex'; // Показываем модалку
    } // Конец функции открытия галереи

    function closeGallery() { // Закрываем модалку галереи
      galleryModal.style.display = 'none'; // Скрываем фон
      currentGalleryKey = null; // Сбрасываем активный ключ
      currentGalleryIndex = 0; // Сбрасываем индекс
    } // Конец функции закрытия галереи

    function stepGallery(delta) { // Переключаемся по списку галереи
      if (!currentGalleryKey) { // Проверяем наличие активной галереи
        return; // Выходим, если модалка закрыта
      } // Конец проверки
      const galleryData = galleryStore[currentGalleryKey]; // Получаем активную галерею
      if (!galleryData || !galleryData.items.length) { // Проверяем наличие данных
        return; // Выходим при отсутствии элементов
      } // Конец проверки
      const total = galleryData.items.length; // Количество элементов
      const nextIndex = (currentGalleryIndex + delta + total) % total; // Вычисляем следующий индекс по кругу
      renderGallerySlide(galleryData, nextIndex); // Обновляем отображение
    } // Конец функции переключения

    galleryClose.addEventListener('click', () => closeGallery()); // Закрываем галерею по кнопке
    galleryPrev.addEventListener('click', () => stepGallery(-1)); // Переход к предыдущему вложению
    galleryNext.addEventListener('click', () => stepGallery(1)); // Переход к следующему вложению
    galleryStrip.addEventListener('click', (evt) => { // Обработчик клика по миниатюрам
      const trigger = evt.target.closest('[data-gallery-index]'); // Ищем кнопку с индексом
      if (!trigger || currentGalleryKey === null) { // Если не нашли или галерея не выбрана
        return; // Выходим
      } // Конец проверки
      const targetIndex = Number(trigger.getAttribute('data-gallery-index')); // Читаем индекс
      const galleryData = galleryStore[currentGalleryKey]; // Берем активную галерею
      if (!galleryData || Number.isNaN(targetIndex)) { // Проверяем корректность данных
        return; // Выходим при ошибке
      } // Конец проверки
      renderGallerySlide(galleryData, targetIndex); // Показываем выбранный элемент
    }); // Конец обработчика клика по миниатюрам
    galleryModal.addEventListener('click', (evt) => { // Подписка на клик по фону
      if (evt.target === galleryModal) { // Проверяем, что кликнули по подложке
        closeGallery(); // Закрываем модалку
      } // Конец проверки цели клика
    }); // Конец обработчика клика по фону
    document.addEventListener('keydown', (evt) => { // Обработка клавиатуры
      if (galleryModal.style.display === 'flex') { // Проверяем, открыта ли модалка
        if (evt.key === 'Escape') { // Если нажали Esc
          closeGallery(); // Закрываем галерею
        } else if (evt.key === 'ArrowLeft') { // Если нажали стрелку влево
          stepGallery(-1); // Переключаемся назад
        } else if (evt.key === 'ArrowRight') { // Если нажали стрелку вправо
          stepGallery(1); // Переключаемся вперед
        } // Конец проверки клавиш
      } // Конец проверки состояния модалки
    }); // Конец обработчика клавиатуры

    document.addEventListener('click', (evt) => { // Делегируем клики по бейджам вложений
      const trigger = evt.target.closest('[data-gallery-key]'); // Ищем ближайший элемент с атрибутом
      if (!trigger) { // Если клик не по бейджу
        return; // Выходим
      } // Конец проверки
      evt.preventDefault(); // Отменяем переход по ссылке
      const key = trigger.getAttribute('data-gallery-key'); // Читаем ключ галереи
      const url = trigger.getAttribute('data-gallery-url'); // Читаем ссылку на вложение
      const originLabel = trigger.getAttribute('data-gallery-origin'); // Читаем источник вложения
      openGallery(key, url, originLabel); // Открываем модалку с нужным вложением
    }); // Конец делегирования кликов

    function renderMessages(messages) { // Функция отрисовки сообщений
      messagesBody.innerHTML = ''; // Очищаем тело таблицы
      resetGalleryStorePreserveActive(); // Сохраняем открытую галерею и очищаем остальное
      galleryCounter = 0; // Обнуляем счетчик ключей
      if (!messages.length) { // Если пусто
        messagesBody.innerHTML = '<tr><td colspan="5" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Выходим
      } // Конец проверки пустоты
      const sortedMessages = [...messages].sort((a, b) => { // Создаем копию и сортируем, чтобы новые были сверху
        const timeA = a?.created_at ? new Date(a.created_at).getTime() : 0; // Вычисляем метку времени первого сообщения
        const timeB = b?.created_at ? new Date(b.created_at).getTime() : 0; // Вычисляем метку времени второго сообщения
        if (timeA !== timeB) { // Если времена различаются
          return timeB - timeA; // Сортируем по убыванию времени
        } // Конец проверки времени
        return (b?.id ?? 0) - (a?.id ?? 0); // Если времени нет, сортируем по убыванию ID
      }); // Конец сортировки
      sortedMessages.forEach((msg) => { // Перебираем сообщения по порядку от новых к старым
        const row = document.createElement('tr'); // Создаем строку
        const galleryKey = `msg-${msg.id ?? 'local'}-${galleryCounter++}`; // Формируем уникальный ключ для галереи
        const normalizedAttachments = extractAttachments(msg); // Нормализуем вложения из сообщения или payload
        const normalizedCopyHistory = extractCopyHistory(msg); // Нормализуем репосты из сообщения или payload
        registerGallery({ ...msg, attachments: normalizedAttachments, copy_history: normalizedCopyHistory }, galleryKey); // Регистрируем вложения для модалки
        const contentCell = buildContentCell(normalizedAttachments, normalizedCopyHistory, galleryKey); // Формируем ячейку контента
        const peerLabel = msg.peer_title || 'Чат без названия'; // Формируем подпись чата без ID
        const authorName = msg.from_name || 'Неизвестный отправитель'; // Формируем подпись автора без технических данных
        const peerCell = buildAvatarLabel(peerLabel, msg.peer_avatar); // Готовим ячейку чата с аватаркой
        const authorCell = `${buildAvatarLabel(authorName, msg.from_avatar)}${msg.is_bot ? ' <span class="badge bg-info text-dark ms-2">бот</span>' : ''}`; // Готовим ячейку автора с аватаркой и бейджем бота
        const replyCell = buildReplyPreview(msg.reply); // Готовим ячейку превью исходного сообщения без ссылок
        row.innerHTML = `<td>${peerCell}</td><td>${authorCell}</td><td>${replyCell}</td><td>${contentCell}</td><td>${msg.text ?? ''}</td>`; // Заполняем ячейки
        messagesBody.appendChild(row); // Добавляем строку в таблицу
      }); // Конец цикла
    } // Конец функции

    function renderPeers(peers) { // Функция отрисовки списка чатов
      const uniquePeers = Array.from( // Формируем массив уникальных чатов
        new Map( // Создаем словарь уникальности по ID
          (peers || []) // Берем входные чаты
            .filter((p) => p && Number.isFinite(p.id)) // Убираем пустые записи
            .map((p) => [p.id, p]) // Превращаем в пары ключ-значение
        ).values() // Берем только значения словаря
      ); // Завершаем сборку массива
      peerSelect.innerHTML = '<option value="">Все чаты</option>'; // Сбрасываем список
      uniquePeers.forEach((peer) => { // Перебираем чаты
        const option = document.createElement('option'); // Создаем опцию
        option.value = peer.id; // Значение
        const label = peer.title ? `${peer.title} (ID: ${peer.id})` : peer.id; // Формируем подпись
        option.textContent = label; // Текст
        peerSelect.appendChild(option); // Добавляем в селектор
      }); // Конец цикла
      if (currentPeer && uniquePeers.some((p) => p.id === Number(currentPeer))) { // Если выбранный чат все еще существует
        peerSelect.value = currentPeer; // Возвращаем выбор
      } else { // Если выбора нет
        currentPeer = ''; // Сбрасываем фильтр
        peerSelect.value = ''; // Возвращаем опцию по умолчанию
      } // Конец условия
    } // Конец функции

    function renderConversations(convs) { // Функция отрисовки диалогов
      conversationsBody.innerHTML = ''; // Очищаем таблицу
      if (!convs.length) { // Если нет данных
        conversationsBody.innerHTML = '<tr><td colspan="4" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Выходим
      } // Конец проверки
      const translatedTypes = { chat: 'беседа', user: 'диалог', group: 'сообщество', unknown: 'неизвестно' }; // Словарь переводов типов
      const sortedConvs = [...convs].sort((a, b) => { // Копируем и сортируем диалоги
        const aHasTitle = Boolean(a?.chat_settings?.title); // Есть ли название у первого диалога
        const bHasTitle = Boolean(b?.chat_settings?.title); // Есть ли название у второго диалога
        if (aHasTitle !== bHasTitle) { // Если различается наличие названия
          return aHasTitle ? -1 : 1; // Сначала диалоги с названием
        } // Конец проверки наличия названия
        const aCount = Number(a?.messages_count ?? 0); // Количество сообщений для первого диалога
        const bCount = Number(b?.messages_count ?? 0); // Количество сообщений для второго диалога
        return bCount - aCount; // Сортируем по убыванию количества сообщений
      }); // Конец сортировки
      sortedConvs.forEach((conv) => { // Перебираем отсортированные диалоги
        const peer = conv.peer || {}; // Получаем peer
        const title = conv.chat_settings?.title || '—'; // Получаем название чата
        const type = peer.type || 'unknown'; // Получаем тип
        const localizedType = translatedTypes[type] || translatedTypes.unknown; // Переводим тип на русский
        const messagesCount = Number(conv.messages_count ?? 0); // Нормализуем количество сообщений
        const avatarUrl = conv.chat_settings?.photo?.photo_50 || conv.chat_settings?.photo?.photo_100 || conv.peer?.avatar; // Определяем ссылку на аватар беседы
        const titleCell = buildAvatarLabel(title, avatarUrl); // Формируем подпись с аватаркой
        const row = document.createElement('tr'); // Создаем строку
        row.innerHTML = `<td>${peer.id ?? '—'}</td><td>${localizedType}</td><td>${titleCell}</td><td>${messagesCount}</td>`; // Заполняем строку
        conversationsBody.appendChild(row); // Добавляем строку
      }); // Конец цикла
    } // Конец функции

    function updateMetrics(stats) { // Функция обновления чисел
      const safeStats = stats || {}; // Нормализуем объект статистики
      const safeTimeline = Array.isArray(safeStats.timeline) ? safeStats.timeline : []; // Готовим безопасный массив таймлайна
      activeMembersEl.textContent = safeStats.invites ?? 0; // Обновляем количество активных участников
      messagesEl.textContent = safeStats.messages ?? 0; // Обновляем количество сообщений
      chart.data.labels = safeTimeline.map((p) => formatDateTime(p.time)); // Обновляем метки графика в локальном формате
      chart.data.datasets[0].data = safeTimeline.map((p) => p.invites ?? 0); // Обновляем линию активных участников
      chart.data.datasets[1].data = safeTimeline.map((p) => p.messages ?? 0); // Обновляем линию сообщений
      chart.update(); // Перерисовываем график
      if (safeStats.range_minutes && timeRangeSelect) { // Если в ответе есть диапазон и селектор существует
        selectedRange = Number(safeStats.range_minutes); // Обновляем выбранный диапазон
        timeRangeSelect.value = String(safeStats.range_minutes); // Синхронизируем значение селектора
      } // Конец проверки диапазона
    } // Конец функции

    function renderStorage(storage) { // Функция вывода информации о файле базы
      storagePathEl.textContent = storage.path || '—'; // Показываем путь до файла
      const sizeKb = storage.size_bytes ? Math.max(1, Math.round(storage.size_bytes / 1024)) : 0; // Переводим байты в килобайты
      storageSizeEl.textContent = storage.size_bytes ? `${sizeKb} КБ` : '0 КБ'; // Показываем размер
      storageStatusEl.textContent = storage.exists ? 'Создан и доступен' : 'Файла пока нет'; // Показываем статус
      storageStatusEl.className = storage.exists ? 'text-success' : 'text-warning'; // Меняем цвет статуса
    } // Конец функции

    function updateImportantBadge(count) { // Функция обновления бейджа важных сообщений
      const safeCount = Number(count) || 0; // Нормализуем значение
      importantBadge.textContent = safeCount; // Выводим число
      importantBadge.className = safeCount > 0 ? 'badge bg-danger fs-6' : 'badge bg-secondary fs-6'; // Меняем цвет по наличию событий
    } // Конец функции бейджа

    function bootstrapPage() { // Инициализация страницы
      renderGroup(initialGroup || {}); // Показываем данные сообщества
      renderConversations(initialConversations || []); // Показываем диалоги
      renderPeers(initialPeers || []); // Показываем стартовые peer_id
      updateMetrics(initialStats || { timeline: [] }); // Показываем метрики
      renderStorage(initialStorage || {}); // Показываем информацию о файле базы
      updateImportantBadge(0); // Сбрасываем бейдж важных сообщений
    } // Конец функции

    async function poll() { // Функция периодического опроса
      try { // Пытаемся отправить запрос
        const logsUrl = currentPeer ? `/api/logs?peer_id=${currentPeer}` : '/api/logs'; // Формируем URL логов
        const alertsUrl = '/api/service-logs?event_type=important&limit=1'; // URL для важных оповещений
        const statsUrl = `/api/stats?range=${selectedRange}`; // Формируем URL статистики с выбранным диапазоном
        const [statsRes, overviewRes, logsRes, alertsRes] = await Promise.all([fetch(statsUrl), fetch('/api/overview'), fetch(logsUrl), fetch(alertsUrl)]); // Запрашиваем статистику, обзор, логи и оповещения
        const stats = await statsRes.json(); // Читаем JSON статистики
        const overview = await overviewRes.json(); // Читаем JSON обзора
        const logs = await logsRes.json(); // Читаем JSON логов
        const alerts = await alertsRes.json(); // Читаем JSON оповещений
        updateMetrics(stats); // Обновляем метрики
        renderGroup(overview.group || {}); // Обновляем информацию о сообществе
        renderConversations(overview.conversations || []); // Обновляем диалоги
        renderPeers(overview.peers || []); // Обновляем список чатов
        renderMessages(logs.items || []); // Обновляем таблицу сообщений
        renderStorage(overview.storage || initialStorage || {}); // Обновляем данные о файле базы
        updateImportantBadge(alerts.total || 0); // Обновляем бейдж важных сообщений
      } catch (err) { // В случае ошибки
        console.error('Ошибка обновления дашборда', err); // Пишем ошибку в консоль
      } // Конец обработки ошибки
    } // Конец функции

    peerSelect.addEventListener('change', () => { // Реагируем на выбор чата
      currentPeer = peerSelect.value; // Сохраняем выбранный peer_id
      poll(); // Перезапрашиваем данные
    }); // Конец обработчика

    bootstrapPage(); // Запускаем инициализацию
    poll(); // Делаем первый запрос сразу после загрузки страницы
    setInterval(poll, 3000); // Опрос каждые 3 секунды
  </script> <!-- Конец скрипта -->
</body> <!-- Конец тела -->
</html> <!-- Конец документа -->
