<!doctype html> <!-- Объявляем тип документа -->
<html lang="ru"> <!-- Указываем язык страницы -->
<head> <!-- Начало заголовка страницы -->
  <meta charset="UTF-8" /> <!-- Кодировка UTF-8 для поддержки русского -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- Масштабирование для мобильных -->
  <title>VK Bot Dashboard</title> <!-- Заголовок вкладки -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" /> <!-- Подключаем Bootstrap -->
  <link rel="preconnect" href="https://fonts.googleapis.com" /> <!-- Оптимизируем загрузку шрифта -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> <!-- Разрешаем кросс-доменную загрузку шрифта -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" /> <!-- Подключаем шрифт Inter -->
  <style> /* Начало пользовательских стилей */
    body { background: #0f172a; color: #e2e8f0; font-family: "Inter", system-ui, -apple-system, sans-serif; } /* Фон и текст */
    .glass { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 18px; backdrop-filter: blur(10px); } /* Стиль стекла */
    .hero { background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.1), transparent 35%), radial-gradient(circle at 80% 0%, rgba(94, 234, 212, 0.08), transparent 30%); } /* Подсветка героя */
    .badge-soft { background: rgba(99, 102, 241, 0.15); color: #c7d2fe; border: 1px solid rgba(99, 102, 241, 0.35); } /* Мягкий бейдж */
    .metric { font-size: 32px; font-weight: 700; } /* Размер цифр метрик */
    .metric-sub { color: #94a3b8; font-size: 14px; } /* Подпись метрик */
    .card-title { font-weight: 700; letter-spacing: 0.02em; } /* Заголовок карточек */
    .table > :not(caption) > * > * { background-color: transparent; color: #e2e8f0; } /* Прозрачный фон таблицы */
    .table-striped > tbody > tr:nth-of-type(odd) > * { background: rgba(255, 255, 255, 0.03); } /* Полосатая таблица */
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(148, 163, 184, 0.4); color: #cbd5e1; font-size: 13px; } /* Пилюли статуса */
    .stat-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; } /* Точка индикатора */
    .shadow-soft { box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25); } /* Мягкая тень */
    .chart-card { min-height: 320px; } /* Минимальная высота графика для компактности */
    .avatar-inline { width: 1.6em; height: 1.6em; border-radius: 999px; object-fit: cover; flex-shrink: 0; } /* Класс для маленьких аватарок по размеру текста */
    .sender-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 12px; border: 1px solid rgba(94, 234, 212, 0.3); background: rgba(94, 234, 212, 0.12); color: #99f6e4; font-size: 12px; } /* Плашка для отметки бота рядом с отправителем */
    .message-row-new { animation: floatDown 0.5s ease; } /* Анимация появления новых сообщений сверху */
    @keyframes floatDown { /* Описание ключевых кадров анимации всплытия */
      from { opacity: 0; transform: translateY(-6px); } /* Начало: прозрачность и легкий подъем */
      to { opacity: 1; transform: translateY(0); } /* Конец: видимое состояние без сдвига */
    } /* Конец анимации */
    .attachment-pill { display: inline-flex; gap: 6px; align-items: center; padding: 4px 10px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.05); color: #e2e8f0; font-size: 12px; text-decoration: none; } /* Пилюля для вложения */
    .attachment-pill:hover { text-decoration: none; background: rgba(255, 255, 255, 0.08); } /* Подсветка при наведении */
    .attachment-pending { border-style: dashed; background: rgba(59, 130, 246, 0.18); color: #cbd5e1; } /* Визуальный акцент ожидания скачивания */
    .attachment-failed { border-style: dashed; background: rgba(248, 113, 113, 0.2); color: #fecaca; border-color: rgba(248, 113, 113, 0.5); } /* Подсветка ошибок скачивания */
    .attachment-photo { border-color: rgba(59, 130, 246, 0.5); color: #bfdbfe; } /* Цвет для фото */
    .attachment-video { border-color: rgba(244, 114, 182, 0.5); color: #fbcfe8; } /* Цвет для видео */
    .attachment-doc { border-color: rgba(74, 222, 128, 0.5); color: #bbf7d0; } /* Цвет для документов */
    .attachment-audio { border-color: rgba(56, 189, 248, 0.5); color: #bae6fd; } /* Цвет для аудио */
    .attachment-sticker { border-color: rgba(248, 180, 0, 0.6); color: #fef08a; } /* Цвет для стикеров */
    .attachment-wall { border-color: rgba(236, 72, 153, 0.6); color: #fbcfe8; } /* Цвет для постов */
    .attachment-link { border-color: rgba(14, 165, 233, 0.5); color: #bae6fd; } /* Цвет для ссылок */
    .attachment-generic { border-color: rgba(148, 163, 184, 0.5); color: #e2e8f0; } /* Цвет для прочего */
    .attachment-group { display: flex; flex-wrap: wrap; gap: 6px; } /* Группа вложений */
    .copy-block { display: flex; flex-direction: column; gap: 4px; padding: 6px 10px; border-radius: 12px; border: 1px dashed rgba(148, 163, 184, 0.35); background: rgba(255, 255, 255, 0.02); } /* Карточка репоста */
    .copy-header { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cbd5e1; } /* Заголовок репоста */
    .copy-attachments { display: flex; flex-wrap: wrap; gap: 6px; } /* Блок вложений внутри репоста */
    .content-cell { display: flex; flex-direction: column; gap: 6px; } /* Ячейка таблицы для контента */
    .gallery-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 16px; } /* Затемненный фон галереи */
    .gallery-body { background: #0b1220; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 16px; max-width: 900px; width: 100%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35); display: flex; flex-direction: column; gap: 12px; padding: 16px; } /* Контейнер галереи */
    .gallery-media { position: relative; min-height: 320px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.03); border-radius: 12px; overflow: hidden; } /* Блок медиа */
    .gallery-media img, .gallery-media video { max-height: 540px; width: 100%; object-fit: contain; border-radius: 12px; background: #0b1220; } /* Медиа внутри галереи */
    .gallery-actions { display: flex; align-items: center; justify-content: space-between; gap: 12px; } /* Кнопки управления */
    .gallery-meta { display: flex; flex-direction: column; gap: 4px; font-size: 14px; color: #cbd5e1; } /* Блок описания контента */
    .gallery-nav-btn { min-width: 42px; } /* Минимальная ширина кнопок навигации */
    .gallery-thumb { margin: 2px; } /* Отступы кнопок миниатюр */
    .gallery-thumb.active { border-width: 2px !important; } /* Подсветка активного вложения */
    .message-deleted > td { background: rgba(248, 113, 113, 0.12) !important; color: #fecdd3; } /* Красноватый фон и текст для удаленных сообщений */
    .message-deleted a { color: #fecdd3; } /* Красноватый цвет ссылок внутри удаленных сообщений */
  </style> <!-- Конец пользовательских стилей -->
</head> <!-- Конец заголовка -->
<body class="pb-5"> <!-- Тело страницы с нижним отступом -->
  <div class="container-fluid py-4"> <!-- Контейнер на всю ширину страницы -->
    <div class="p-4 p-md-5 mb-4 hero glass shadow-soft"> <!-- Блок героя -->
      <div class="d-flex align-items-center justify-content-between flex-wrap gap-3"> <!-- Верхняя строка героя -->
        <div> <!-- Левая часть -->
          <div class="d-inline-flex align-items-center gap-2 mb-2"> <!-- Бейджи статуса -->
            <span class="pill"> <!-- Пилюля статуса -->
              <span class="stat-dot bg-info"></span> <!-- Точка состояния -->
              Мониторинг активен <!-- Текст статуса -->
            </span> <!-- Конец пилюли -->
            <span class="pill" id="demo-badge" style="display: none;"> <!-- Пилюля демо -->
              <span class="stat-dot bg-warning"></span> <!-- Точка демо -->
              Демо-режим <!-- Подпись демо -->
            </span> <!-- Конец пилюли демо -->
          </div> <!-- Конец блока бейджей -->
          <h1 class="fw-bold mb-2">Дашборд VK-бота</h1> <!-- Заголовок героя -->
          <p class="text-secondary mb-0">Живые метрики лонгпулла, графики и последние сообщения без отправки от лица сообщества.</p> <!-- Подзаголовок -->
        </div> <!-- Конец левой части -->
        <div class="text-end"> <!-- Правая часть -->
          <div class="card glass shadow-soft px-4 py-3"> <!-- Карточка информации -->
            <div class="text-secondary small">Сообщество</div> <!-- Подпись -->
            <div class="fw-semibold text-light" id="group-name">—</div> <!-- Имя сообщества с более контрастным цветом -->
            <div class="text-secondary small" id="group-id">—</div> <!-- ID или адрес -->
            <div class="text-secondary small" id="group-members">—</div> <!-- Количество участников -->
          </div> <!-- Конец карточки -->
        </div> <!-- Конец правой части -->
      </div> <!-- Конец верхней строки героя -->
    </div> <!-- Конец героя -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок важных сообщений -->
      <div class="d-flex flex-wrap align-items-center justify-content-between gap-3"> <!-- Контейнер заголовка -->
        <div> <!-- Левая часть блока -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Здесь появляются критичные сигналы от сервиса">Важные сообщения</div> <!-- Заголовок блока с подсказкой -->
          <div class="text-secondary small">Ошибки и предупреждения сервисных процессов.</div> <!-- Подпись -->
        </div> <!-- Конец левой части -->
        <div class="d-flex align-items-center gap-2"> <!-- Правая часть -->
          <span id="important-badge" class="badge bg-danger fs-6">0</span> <!-- Бейдж количества -->
          <a href="http://127.0.0.1:8000/logs/full#service-alerts" class="btn btn-outline-light btn-sm">Перейти к оповещениям</a> <!-- Кнопка перехода с якорем на сервисные логи -->
        </div> <!-- Конец правой части -->
      </div> <!-- Конец контейнера -->
    </div> <!-- Конец блока важных сообщений -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок выбора чата -->
      <div class="d-flex flex-column flex-lg-row align-items-lg-center justify-content-between gap-3"> <!-- Контейнер -->
        <div> <!-- Левая колонка -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Настройте, из каких чатов получать логи">Источник данных</div> <!-- Заголовок с подсказкой -->
          <div class="text-secondary small">Выберите конкретный peer_id или смотрите сразу все сообщения.</div> <!-- Подпись -->
        </div> <!-- Конец левой колонки -->
        <div class="d-flex flex-column flex-md-row gap-2 align-items-md-center"> <!-- Контейнер селектора -->
          <label class="text-secondary small mb-0" for="peer-select">Фильтр по чату</label> <!-- Подпись селектора -->
          <select id="peer-select" class="form-select bg-dark text-light border-secondary" style="min-width: 240px"> <!-- Селектор чатов -->
            <option value="">Все чаты</option> <!-- Опция по умолчанию -->
          </select> <!-- Конец селектора -->
        </div> <!-- Конец контейнера селектора -->
      </div> <!-- Конец контейнера -->
    </div> <!-- Конец блока выбора чата -->

    <div class="glass shadow-soft p-4 mb-4"> <!-- Блок информации о хранилище -->
      <div class="d-flex flex-column gap-3"> <!-- Вертикальный контейнер -->
        <div> <!-- Заголовок блока -->
          <div class="card-title mb-1" data-bs-toggle="tooltip" title="Локальный файл базы, папка вложений и кэш стикеров">Хранилище логов и файлов</div> <!-- Заголовок с подсказкой -->
          <div class="text-secondary small">Следите за размером базы, вложений и кэша стикеров, чтобы диск не переполнялся.</div> <!-- Подпись блока -->
        </div> <!-- Конец заголовка -->
        <div class="row g-3 align-items-start"> <!-- Строка с тремя колонками -->
          <div class="col-12 col-xl-4"> <!-- Колонка файла базы -->
            <div class="text-secondary small"> <!-- Контент базы -->
              <div><span class="text-light">Путь базы:</span> <span id="storage-path">—</span></div> <!-- Строка пути базы -->
              <div><span class="text-light">Размер базы:</span> <span id="storage-size">—</span></div> <!-- Строка размера базы -->
              <div><span class="text-light">Статус базы:</span> <span id="storage-status">—</span></div> <!-- Строка статуса базы -->
            </div> <!-- Конец контента базы -->
          </div> <!-- Конец колонки файла базы -->
          <div class="col-12 col-xl-4"> <!-- Колонка вложений -->
            <div class="text-secondary small"> <!-- Контент вложений -->
              <div><span class="text-light">Папка вложений:</span> <span id="attachments-path">—</span></div> <!-- Строка пути вложений -->
              <div><span class="text-light">Размер вложений:</span> <span id="attachments-size">—</span></div> <!-- Строка размера вложений -->
              <div><span class="text-light">Статус вложений:</span> <span id="attachments-status">—</span></div> <!-- Строка статуса вложений -->
            </div> <!-- Конец контента вложений -->
          </div> <!-- Конец колонки вложений -->
          <div class="col-12 col-xl-4"> <!-- Колонка кэша стикеров -->
            <div class="text-secondary small"> <!-- Контент кэша стикеров -->
              <div><span class="text-light">Кэш стикеров:</span> <span id="sticker-cache-path">—</span></div> <!-- Строка пути кэша -->
              <div><span class="text-light">Размер кэша:</span> <span id="sticker-cache-size">—</span></div> <!-- Строка размера кэша -->
              <div><span class="text-light">Статус кэша:</span> <span id="sticker-cache-status">—</span></div> <!-- Строка статуса кэша -->
            </div> <!-- Конец контента кэша стикеров -->
          </div> <!-- Конец колонки кэша стикеров -->
        </div> <!-- Конец строки -->
      </div> <!-- Конец вертикального контейнера -->
    </div> <!-- Конец блока информации о хранилище -->

    <div class="row g-4 mb-4"> <!-- Строка метрик -->
      <div class="col-12 col-lg-6"> <!-- Колонка активных участников -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка -->
            <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок карточки -->
              <div class="card-title" data-bs-toggle="tooltip" title="Сколько уникальных людей активно взаимодействуют">Активные участники</div> <!-- Текст с подсказкой -->
              <span class="badge-soft badge rounded-pill">Live</span> <!-- Бейдж -->
            </div> <!-- Конец заголовка -->
            <div class="metric" id="active-members-count">0</div> <!-- Число активных участников -->
          <div class="metric-sub">За последние события</div> <!-- Подпись -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
      <div class="col-12 col-lg-6"> <!-- Колонка сообщений -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка -->
            <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок карточки -->
              <div class="card-title" data-bs-toggle="tooltip" title="Количество входящих сообщений">Сообщения</div> <!-- Текст с подсказкой -->
              <span class="badge bg-info text-dark">Входящие</span> <!-- Бейдж -->
            </div> <!-- Конец заголовка -->
            <div class="metric" id="messages-count">0</div> <!-- Число сообщений -->
          <div class="metric-sub">Новые за сессию</div> <!-- Подпись -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
    </div> <!-- Конец строки метрик -->
    <div class="row g-4 mb-4"> <!-- Строка с графиком и диалогами -->
      <div class="col-12 col-xl-6"> <!-- Колонка с графиком -->
        <div class="glass p-4 shadow-soft chart-card"> <!-- Карточка графика -->
          <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <!-- Заголовок графика -->
            <div> <!-- Левая часть заголовка графика -->
              <div class="card-title mb-1" data-bs-toggle="tooltip" title="График активности участников и новых сообщений">Динамика активности</div> <!-- Название с подсказкой -->
              <div class="text-secondary small">Обновляется каждые 3 секунды</div> <!-- Подпись -->
            </div> <!-- Конец левой части заголовка графика -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер для селектора диапазона и статуса -->
              <select class="form-select form-select-sm bg-dark text-light" id="time-range-select"> <!-- Селектор временного диапазона -->
                <option value="15">15 минут</option> <!-- Опция 15 минут -->
                <option value="60">1 час</option> <!-- Опция 1 час -->
                <option value="360">6 часов</option> <!-- Опция 6 часов -->
                <option value="1440">24 часа</option> <!-- Опция 24 часа -->
              </select> <!-- Конец селектора -->
              <span class="pill"> <!-- Индикатор статуса лонгпулла -->
                <span class="stat-dot bg-info"></span> <!-- Точка -->
                Лонгпулл активен <!-- Подпись -->
              </span> <!-- Конец индикатора -->
            </div> <!-- Конец контейнера -->
          </div> <!-- Конец заголовка -->
          <canvas id="events-chart" height="260"></canvas> <!-- Полотно графика -->
        </div> <!-- Конец карточки графика -->
      </div> <!-- Конец колонки графика -->
      <div class="col-12 col-xl-6"> <!-- Колонка диалогов -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка диалогов -->
          <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок -->
            <div class="card-title mb-1" data-bs-toggle="tooltip" title="Список диалогов, доступных боту">Диалоги и чаты</div> <!-- Название с подсказкой -->
            <span class="badge bg-secondary">Read-only</span> <!-- Бейдж -->
          </div> <!-- Конец заголовка -->
          <div class="table-responsive"> <!-- Обертка таблицы -->
            <table class="table table-striped align-middle mb-0"> <!-- Таблица диалогов -->
              <thead class="text-secondary"> <!-- Заголовок -->
                <tr> <!-- Строка заголовка таблицы -->
                  <th>peer_id</th> <!-- Заголовок идентификатора чата -->
                  <th>Тип</th> <!-- Заголовок типа диалога -->
                  <th>Название</th> <!-- Заголовок названия чата -->
                  <th>Сообщений</th> <!-- Заголовок количества сообщений -->
                </tr> <!-- Конец строки заголовка таблицы -->
              </thead> <!-- Конец заголовка таблицы -->
              <tbody id="conversations-body"> <!-- Тело -->
                <tr> <!-- Строка-заглушка диалогов -->
                  <td colspan="4" class="text-secondary">Нет данных</td> <!-- Плейсхолдер -->
                </tr> <!-- Конец строки-заглушки диалогов -->
              </tbody> <!-- Конец тела таблицы -->
            </table> <!-- Конец таблицы -->
          </div> <!-- Конец обертки -->
        </div> <!-- Конец карточки -->
      </div> <!-- Конец колонки -->
    </div> <!-- Конец строки с графиком и диалогами -->

    <div class="row g-4"> <!-- Строка для последних сообщений в самом низу -->
      <div class="col-12"> <!-- Единственная колонка на всю ширину -->
        <div class="glass p-4 shadow-soft h-100"> <!-- Карточка сообщений -->
          <div class="d-flex justify-content-between align-items-center mb-3"> <!-- Заголовок -->
            <div> <!-- Левая часть заголовка -->
              <div class="card-title mb-1" data-bs-toggle="tooltip" title="Свежие сообщения с сортировкой сверху вниз">Последние сообщения</div> <!-- Название с подсказкой -->
              <div class="text-secondary small">Новые сверху, таблица растягивается на всю ширину контейнера</div> <!-- Подпись с уточнением ширины -->
            </div> <!-- Конец левой части заголовка -->
            <div class="d-flex align-items-center gap-2"> <!-- Контейнер кнопок -->
              <span class="badge-soft badge rounded-pill" id="timezone-badge" title="">Локальное время</span> <!-- Бейдж с подсказкой о часовом поясе -->
              <span class="badge-soft badge rounded-pill">READ ONLY</span> <!-- Бейдж readonly -->
              <a href="/logs/full" class="btn btn-outline-light btn-sm"> <!-- Кнопка просмотра всех сообщений -->
                Посмотреть все <!-- Текст кнопки -->
              </a> <!-- Конец кнопки -->
            </div> <!-- Конец контейнера кнопок -->
          </div> <!-- Конец заголовка -->
          <div class="table-responsive"> <!-- Обертка таблицы -->
            <table class="table table-sm table-striped align-middle mb-0"> <!-- Таблица сообщений -->
              <thead class="text-secondary"> <!-- Заголовок таблицы -->
                <tr> <!-- Строка заголовка -->
                  <th>Чат</th> <!-- Заголовок столбца -->
                  <th>Отправитель</th> <!-- Заголовок столбца с автором и пометкой бота -->
                  <th>Ответ</th> <!-- Заголовок столбца -->
                  <th>Вложения</th> <!-- Заголовок столбца -->
                  <th>Текст</th> <!-- Заголовок столбца -->
                </tr> <!-- Конец строки заголовка -->
              </thead> <!-- Конец заголовка таблицы -->
              <tbody id="messages-body"> <!-- Тело таблицы -->
                <tr> <!-- Строка-заглушка -->
                  <td colspan="5" class="text-secondary">Нет данных</td> <!-- Плейсхолдер -->
                </tr> <!-- Конец строки-заглушки -->
              </tbody> <!-- Конец тела таблицы -->
            </table> <!-- Конец таблицы -->
          </div> <!-- Конец обертки таблицы -->
        </div> <!-- Конец карточки сообщений -->
      </div> <!-- Конец единственной колонки -->
    </div> <!-- Конец строки для сообщений -->
  </div> <!-- Конец контейнера -->

  {% include 'partials/gallery.html' %} <!-- Подключаем общую разметку модального окна галереи -->

  <script src="{{ url_for('static', filename='js/gallery.js') }}"></script> <!-- Подключаем общий скрипт галереи -->
  <script src="{{ url_for('static', filename='js/chat-history.js') }}"></script> <!-- Подключаем единый модуль истории чата -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script> <!-- Подключаем Bootstrap JS для тултипов -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> <!-- Подключаем Chart.js -->
  <script> // Начало скрипта
    const initialStats = {{ initial_stats|tojson }}; // Читаем стартовые метрики из шаблона без ручного парсинга, чтобы не было ошибок на кавычках
    const initialGroup = {{ initial_group|tojson }}; // Читаем информацию о сообществе в безопасном виде
    const initialConversations = {{ initial_conversations|tojson }}; // Читаем список диалогов без риска испортить JSON
    const initialPeers = {{ initial_peers|tojson }}; // Читаем стартовый список peer_id без ошибок экранирования
    const initialStorage = {{ initial_storage|tojson }}; // Читаем стартовую информацию о файле базы
    const demoMode = {{ 'true' if demo_mode else 'false' }}; // Флаг демо-режима

    const activeMembersEl = document.getElementById('active-members-count'); // Находим элемент активных участников
    const messagesEl = document.getElementById('messages-count'); // Находим элемент сообщений
    const messagesBody = document.getElementById('messages-body'); // Тело таблицы сообщений
    const conversationsBody = document.getElementById('conversations-body'); // Тело таблицы диалогов
    const groupNameEl = document.getElementById('group-name'); // Заголовок сообщества
    const groupIdEl = document.getElementById('group-id'); // ID сообщества
    const groupMembersEl = document.getElementById('group-members'); // Количество участников
    const demoBadge = document.getElementById('demo-badge'); // Бейдж демо
    const peerSelect = document.getElementById('peer-select'); // Селектор чатов
    const storagePathEl = document.getElementById('storage-path'); // Путь до файла базы
    const storageSizeEl = document.getElementById('storage-size'); // Размер файла базы
    const storageStatusEl = document.getElementById('storage-status'); // Статус существования файла
    const attachmentsPathEl = document.getElementById('attachments-path'); // Путь до папки вложений
    const attachmentsSizeEl = document.getElementById('attachments-size'); // Размер всех вложений
    const attachmentsStatusEl = document.getElementById('attachments-status'); // Статус существования папки вложений
    const stickerCachePathEl = document.getElementById('sticker-cache-path'); // Путь к кэшу стикеров
    const stickerCacheSizeEl = document.getElementById('sticker-cache-size'); // Размер кэша стикеров
    const stickerCacheStatusEl = document.getElementById('sticker-cache-status'); // Статус кэша стикеров
    const importantBadge = document.getElementById('important-badge'); // Бейдж важных оповещений
    const timeRangeSelect = document.getElementById('time-range-select'); // Селектор выбора диапазона времени
    const galleryApi = window.galleryBridge || {}; // Получаем общий API галереи из подключенного файла
    const chatApi = window.chatHistory || {}; // Получаем единый модуль истории чата
    let currentPeer = ''; // Текущий выбранный peer_id
    let selectedRange = Number(initialStats?.range_minutes ?? 60); // Текущий выбранный диапазон минут

    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions(); // Считываем параметры локальной таймзоны браузера
    const timezoneOffsetMinutes = new Date().getTimezoneOffset(); // Получаем смещение от UTC в минутах
    const timezoneOffsetSign = timezoneOffsetMinutes <= 0 ? '+' : '-'; // Определяем знак смещения
    const timezoneOffsetHours = String(Math.floor(Math.abs(timezoneOffsetMinutes) / 60)).padStart(2, '0'); // Вычисляем часы смещения с ведущим нулем
    const timezoneOffsetRestMinutes = String(Math.abs(timezoneOffsetMinutes) % 60).padStart(2, '0'); // Вычисляем минуты смещения с ведущим нулем
    const timezoneLabel = `UTC${timezoneOffsetSign}${timezoneOffsetHours}:${timezoneOffsetRestMinutes} (${timezoneInfo.timeZone || 'локальное время'})`; // Формируем подпись таймзоны и смещения
    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: timezoneInfo.timeZone, timeZoneName: 'short' }); // Настраиваем формат вывода времени

    document.getElementById('timezone-badge').title = `Отображается время ${timezoneLabel}`; // Обновляем подсказку бейджа таймзоны

    const tooltipTriggerList = Array.from(document.querySelectorAll('[data-bs-toggle="tooltip"]')); // Собираем все элементы, на которых нужно активировать тултипы
    tooltipTriggerList.forEach((triggerEl) => new bootstrap.Tooltip(triggerEl)); // Инициализируем Bootstrap тултипы для каждого элемента

    if (timeRangeSelect) { // Если селектор диапазона найден
      timeRangeSelect.value = String(selectedRange); // Устанавливаем текущее значение из стартовых данных
      timeRangeSelect.addEventListener('change', () => { // Подписываемся на изменение диапазона
        selectedRange = Number(timeRangeSelect.value || 60); // Обновляем выбранный диапазон
        poll(); // Запускаем немедленное обновление данных
      }); // Конец обработчика изменения
    } // Конец проверки селектора

    function formatDateTime(value) { // Функция форматирования даты
      const parsed = value ? new Date(value) : null; // Создаем объект даты при наличии значения
      return parsed && !Number.isNaN(parsed.valueOf()) ? timeFormatter.format(parsed) : '—'; // Возвращаем отформатированную строку или тире
    } // Конец функции форматирования

    if (demoMode) { // Если включен демо-режим
      demoBadge.style.display = 'inline-flex'; // Показываем бейдж демо
    } // Конец условия демо

    const ctx = document.getElementById('events-chart'); // Получаем холст графика
    const chart = new Chart(ctx, { // Создаем график
      type: 'line', // Тип графика
      data: { // Данные графика
        labels: initialStats.timeline.map((p) => formatDateTime(p.time)), // Метки времени в локальном формате
        datasets: [ // Наборы данных
          { label: 'Активные участники', data: initialStats.timeline.map((p) => p.invites), borderColor: '#fbbf24', backgroundColor: 'rgba(251,191,36,0.25)', tension: 0.3, fill: true }, // Линия активных участников
          { label: 'Сообщения', data: initialStats.timeline.map((p) => p.messages), borderColor: '#34d399', backgroundColor: 'rgba(52,211,153,0.25)', tension: 0.3, fill: true }, // Линия сообщений
        ], // Конец наборов
      }, // Конец данных
      options: { // Настройки графика
        plugins: { legend: { labels: { color: '#cbd5e1' } } }, // Цвет легенды
        scales: { // Настройки осей
          x: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.04)' } }, // Ось X
          y: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.04)' } }, // Ось Y
        }, // Конец осей
      }, // Конец настроек
    }); // Конец создания графика

    function renderGroup(data) { // Функция вывода информации о сообществе
      groupNameEl.textContent = data.name || '—'; // Отображаем название
      groupIdEl.textContent = data.screen_name ? `vk.com/${data.screen_name}` : 'ID: ' + (data.id || '—'); // Отображаем адрес
      groupMembersEl.textContent = data.members_count ? `${data.members_count} участников` : 'Участники: —'; // Отображаем участников
    } // Конец функции

    const pageSize = {{ page_size | tojson }}; // Размер страницы для подгрузки логов
    const serverMessages = {{ initial_logs | tojson }}; // Стартовый набор логов с сервера
    let renderedMessageKeys = new Set(); // Хранилище ключей уже отрисованных сообщений
    let messagesStore = Array.isArray(serverMessages) ? [...serverMessages] : []; // Локальное хранилище сообщений
    let messageGalleryCounter = 0; // Счетчик ключей галереи для сообщений
    let currentOffset = messagesStore.length; // Текущее смещение для следующей страницы
    let hasMore = messagesStore.length === pageSize; // Флаг наличия следующих страниц для подгрузки
    let isLoadingOlder = false; // Флаг процесса загрузки старых сообщений
    let isFetchingLatest = false; // Флаг процесса загрузки новых сообщений

    const resetGalleryStore = () => { // Унифицированная очистка галереи перед полной перерисовкой
      if (galleryApi.resetGalleryStorePreserveActive) { // Проверяем наличие функции сброса в общем модуле галереи
        galleryApi.resetGalleryStorePreserveActive(); // Сбрасываем галерею, сохраняя открытое состояние
      } // Конец проверки наличия функции
    }; // Конец вспомогательной функции

    const buildMessageKey = (msg) => { // Формируем уникальный ключ сообщения
      const messageKeyParts = [ // Собираем части ключа
        msg.id ?? 'unknown', // Добавляем ID записи лога
        msg.peer_id ?? 'no-peer', // Добавляем идентификатор чата
        msg.created_at ?? msg.date ?? msg.timestamp ?? 'no-time', // Добавляем время создания
        msg.text || '', // Добавляем текст, чтобы различать записи без ID
      ]; // Конец сборки частей ключа
      return messageKeyParts.join('::'); // Склеиваем части в строку
    }; // Конец функции формирования ключа

    const ensurePlaceholder = () => { // Отрисовываем плейсхолдер при пустой таблице
      const placeholderRow = document.getElementById('messages-placeholder'); // Ищем существующий плейсхолдер
      if (placeholderRow) { // Если плейсхолдер уже есть
        return; // Ничего не делаем
      } // Конец проверки наличия
      const row = document.createElement('tr'); // Создаем строку для плейсхолдера
      row.id = 'messages-placeholder'; // Добавляем идентификатор
      row.innerHTML = '<td colspan="5" class="text-secondary">Нет данных</td>'; // Заполняем текст плейсхолдера
      messagesBody.appendChild(row); // Добавляем строку в таблицу
    }; // Конец функции плейсхолдера

    const clearPlaceholder = () => { // Удаляем плейсхолдер, если он есть
      const placeholderRow = document.getElementById('messages-placeholder'); // Ищем строку плейсхолдера
      if (placeholderRow) { // Если нашли
        placeholderRow.remove(); // Удаляем строку
      } // Конец проверки наличия
    }; // Конец функции удаления плейсхолдера

    const renderMessagesChunk = (messages, { mode = 'append' } = {}) => { // Рисуем часть сообщений с учетом режима
      if (mode === 'replace') { // Если нужно полностью перерисовать таблицу
        messagesBody.innerHTML = ''; // Полностью очищаем тело таблицы
        resetGalleryStore(); // Сбрасываем состояние галереи
        renderedMessageKeys.clear(); // Очищаем множество ключей
        messageGalleryCounter = 0; // Обнуляем счетчик галереи
      } // Конец проверки режима полной перерисовки
      if (!Array.isArray(messages) || messages.length === 0) { // Если данных нет
        if (mode === 'replace') { // Для режима полной перерисовки
          ensurePlaceholder(); // Добавляем плейсхолдер
        } // Конец проверки режима
        return; // Завершаем выполнение
      } // Конец проверки наличия данных
      clearPlaceholder(); // Убираем плейсхолдер перед вставкой новых строк
      const fragment = document.createDocumentFragment(); // Создаем фрагмент для батчевой вставки
      messages.forEach((msg) => { // Перебираем все сообщения из порции
        const messageKey = buildMessageKey(msg); // Формируем ключ текущего сообщения
        if (renderedMessageKeys.has(messageKey)) { // Проверяем, не показывали ли его раньше
          return; // Пропускаем дубли
        } // Конец проверки дубля
        renderedMessageKeys.add(messageKey); // Сохраняем ключ как отрисованный
        const galleryKey = `msg-${msg.id ?? 'local'}-${messageGalleryCounter++}`; // Генерируем ключ для галереи
        const row = chatApi.buildDashboardRow(msg, galleryApi, galleryKey, { isNew: mode === 'prepend' }); // Собираем строку через модуль истории
        fragment.appendChild(row); // Добавляем строку в фрагмент
      }); // Конец перебора порции
      if (mode === 'prepend') { // Если нужно добавить новые строки сверху
        messagesBody.prepend(fragment); // Вставляем фрагмент в начало таблицы
      } else { // Иначе добавляем в конец
        messagesBody.appendChild(fragment); // Вставляем фрагмент в конец таблицы
      } // Конец проверки режима вставки
    }; // Конец функции рендера порции

    const loadOlderMessages = async () => { // Подгружаем старшие записи при прокрутке вниз
      if (isLoadingOlder || !hasMore) { // Проверяем возможность загрузки
        return; // Прерываем выполнение
      } // Конец проверки флагов
      isLoadingOlder = true; // Ставим флаг процесса загрузки
      try { // Пытаемся запросить данные
        const params = new URLSearchParams({ limit: pageSize, offset: currentOffset }); // Формируем параметры запроса
        if (currentPeer) { // Если выбран фильтр чата
          params.set('peer_id', currentPeer); // Добавляем peer_id
        } // Конец проверки фильтра
        const response = await fetch(`/api/logs?${params.toString()}`); // Выполняем запрос к API логов
        const data = await response.json(); // Читаем JSON-ответ
        const items = data.items || []; // Забираем массив сообщений
        if (items.length) { // Если пришли данные
          renderMessagesChunk(items, { mode: 'append' }); // Добавляем их в конец таблицы
          messagesStore = messagesStore.concat(items); // Сохраняем порцию в локальное хранилище
          currentOffset = renderedMessageKeys.size; // Обновляем смещение по количеству отрисованных записей
          hasMore = items.length === pageSize; // Фиксируем, есть ли следующая страница
        } else { // Если данных нет
          hasMore = false; // Помечаем, что подгружать больше нечего
        } // Конец проверки наличия данных
      } catch (err) { // Обработка ошибок запроса
        console.error('Не удалось подгрузить старые сообщения', err); // Пишем ошибку в консоль
        hasMore = false; // Останавливаем попытки подгрузки
      } finally { // Финальный блок
        isLoadingOlder = false; // Сбрасываем флаг загрузки
      } // Конец финального блока
    }; // Конец функции подгрузки старых сообщений

    const fetchLatestMessages = async () => { // Загружаем новые сообщения без сброса ленты
      if (isFetchingLatest) { // Проверяем, не идет ли уже запрос
        return; // Прерываем выполнение
      } // Конец проверки
      isFetchingLatest = true; // Ставим флаг текущего запроса
      try { // Пытаемся запросить свежие данные
        const params = new URLSearchParams({ limit: pageSize }); // Формируем параметры без смещения
        if (currentPeer) { // Если выбран фильтр
          params.set('peer_id', currentPeer); // Добавляем фильтр peer_id
        } // Конец проверки фильтра
        const response = await fetch(`/api/logs?${params.toString()}`); // Выполняем запрос к API логов
        const data = await response.json(); // Читаем JSON-ответ
        const items = data.items || []; // Забираем массив сообщений
        const freshItems = []; // Готовим массив новых записей
        items.forEach((msg) => { // Перебираем свежие записи
          const messageKey = buildMessageKey(msg); // Формируем ключ сообщения
          if (!renderedMessageKeys.has(messageKey)) { // Если сообщение еще не отрисовано
            freshItems.push(msg); // Добавляем в список новых
          } // Конец проверки дубликата
        }); // Конец перебора свежих записей
        if (freshItems.length) { // Если есть новые сообщения
          renderMessagesChunk(freshItems, { mode: 'prepend' }); // Добавляем их в начало таблицы
          messagesStore = freshItems.concat(messagesStore); // Обновляем локальное хранилище, добавляя свежие записи
          currentOffset = renderedMessageKeys.size; // Пересчитываем смещение
          hasMore = true; // После появления новых данных разрешаем дальнейшие подгрузки
        } // Конец проверки наличия новых сообщений
      } catch (err) { // Обработка ошибок загрузки
        console.error('Не удалось загрузить новые сообщения', err); // Пишем ошибку в консоль
      } finally { // Финальный блок
        isFetchingLatest = false; // Сбрасываем флаг
      } // Конец финального блока
    }; // Конец функции загрузки новых сообщений

    const reloadMessages = async () => { // Полностью перезагружаем ленту при смене фильтра
      isLoadingOlder = true; // Ставим флаг загрузки
      try { // Пытаемся запросить первую страницу
        const params = new URLSearchParams({ limit: pageSize, offset: 0 }); // Параметры первой страницы
        if (currentPeer) { // Если выбран peer_id
          params.set('peer_id', currentPeer); // Добавляем фильтр в запрос
        } // Конец проверки фильтра
        const response = await fetch(`/api/logs?${params.toString()}`); // Делаем запрос
        const data = await response.json(); // Читаем ответ
        messagesStore = data.items || []; // Сохраняем новую порцию в хранилище
        currentOffset = messagesStore.length; // Обновляем смещение
        hasMore = messagesStore.length === pageSize; // Ставим флаг наличия следующих страниц
        renderMessagesChunk(messagesStore, { mode: 'replace' }); // Полностью перерисовываем таблицу
      } catch (err) { // Обработка ошибок загрузки
        console.error('Не удалось перезагрузить ленту сообщений', err); // Логируем ошибку
        messagesStore = []; // Сбрасываем хранилище
        currentOffset = 0; // Сбрасываем смещение
        hasMore = false; // Отключаем подгрузку
        renderMessagesChunk([], { mode: 'replace' }); // Показываем плейсхолдер
      } finally { // Финальный блок
        isLoadingOlder = false; // Снимаем флаг загрузки
      } // Конец финального блока
    }; // Конец функции полной перезагрузки

    const handleScroll = () => { // Обработчик прокрутки страницы
      const scrollPosition = window.scrollY + window.innerHeight; // Текущая позиция прокрутки
      const threshold = document.documentElement.scrollHeight - 400; // Порог начала подгрузки
      if (scrollPosition >= threshold) { // Если подошли к порогу
        loadOlderMessages(); // Запрашиваем старые сообщения
      } // Конец проверки порога
    }; // Конец обработчика прокрутки

    renderMessagesChunk(messagesStore, { mode: 'replace' }); // Рисуем стартовую таблицу из серверных данных
    if (hasMore) { // Если есть данные для подгрузки
      loadOlderMessages(); // Сразу запрашиваем следующую порцию для плавной ленты
    } // Конец проверки наличия данных
    window.addEventListener('scroll', handleScroll); // Подписываемся на прокрутку для бесконечной ленты

    function renderPeers(peers) { // Функция отрисовки списка чатов
      const uniquePeers = Array.from( // Формируем массив уникальных чатов
        new Map( // Создаем словарь уникальности по ID
          (peers || []) // Берем входные чаты
            .filter((p) => p && Number.isFinite(p.id)) // Убираем пустые записи
            .map((p) => [p.id, p]) // Превращаем в пары ключ-значение
        ).values() // Берем только значения словаря
      ); // Завершаем сборку массива
      peerSelect.innerHTML = '<option value="">Все чаты</option>'; // Сбрасываем список
      uniquePeers.forEach((peer) => { // Перебираем чаты
        const option = document.createElement('option'); // Создаем опцию
        option.value = peer.id; // Значение
        const label = peer.title ? `${peer.title} (ID: ${peer.id})` : peer.id; // Формируем подпись
        option.textContent = label; // Текст
        peerSelect.appendChild(option); // Добавляем в селектор
      }); // Конец цикла
      if (currentPeer && uniquePeers.some((p) => p.id === Number(currentPeer))) { // Если выбранный чат все еще существует
        peerSelect.value = currentPeer; // Возвращаем выбор
      } else { // Если выбора нет
        currentPeer = ''; // Сбрасываем фильтр
        peerSelect.value = ''; // Возвращаем опцию по умолчанию
      } // Конец условия
    } // Конец функции

    function renderConversations(convs) { // Функция отрисовки диалогов
      conversationsBody.innerHTML = ''; // Очищаем таблицу
      if (!convs.length) { // Если нет данных
        conversationsBody.innerHTML = '<tr><td colspan="4" class="text-secondary">Нет данных</td></tr>'; // Плейсхолдер
        return; // Выходим
      } // Конец проверки
      const translatedTypes = { chat: 'беседа', user: 'диалог', group: 'сообщество', unknown: 'неизвестно' }; // Словарь переводов типов
      const sortedConvs = [...convs].sort((a, b) => { // Копируем и сортируем диалоги
        const aHasTitle = Boolean(a?.chat_settings?.title); // Есть ли название у первого диалога
        const bHasTitle = Boolean(b?.chat_settings?.title); // Есть ли название у второго диалога
        if (aHasTitle !== bHasTitle) { // Если различается наличие названия
          return aHasTitle ? -1 : 1; // Сначала диалоги с названием
        } // Конец проверки наличия названия
        const aCount = Number(a?.messages_count ?? 0); // Количество сообщений для первого диалога
        const bCount = Number(b?.messages_count ?? 0); // Количество сообщений для второго диалога
        return bCount - aCount; // Сортируем по убыванию количества сообщений
      }); // Конец сортировки
      sortedConvs.forEach((conv) => { // Перебираем отсортированные диалоги
        const peer = conv.peer || {}; // Получаем peer
        const title = conv.chat_settings?.title || '—'; // Получаем название чата
        const type = peer.type || 'unknown'; // Получаем тип
        const localizedType = translatedTypes[type] || translatedTypes.unknown; // Переводим тип на русский
        const messagesCount = Number(conv.messages_count ?? 0); // Нормализуем количество сообщений
        const avatarUrl = conv.chat_settings?.photo?.photo_50 || conv.chat_settings?.photo?.photo_100 || conv.peer?.avatar; // Определяем ссылку на аватар беседы
        const titleCell = peer.id ? `<a href="/chat/${peer.id}" target="_blank" class="text-decoration-none text-light d-inline-flex align-items-center gap-2">${chatApi.buildAvatarLabel(title, avatarUrl)}</a>` : chatApi.buildAvatarLabel(title, avatarUrl); // Формируем подпись с аватаркой и ссылкой
        const row = document.createElement('tr'); // Создаем строку
        row.innerHTML = `<td>${peer.id ?? '—'}</td><td>${localizedType}</td><td>${titleCell}</td><td>${messagesCount}</td>`; // Заполняем строку
        conversationsBody.appendChild(row); // Добавляем строку
      }); // Конец цикла
    } // Конец функции

    function updateMetrics(stats) { // Функция обновления чисел
      const safeStats = stats || {}; // Нормализуем объект статистики
      const safeTimeline = Array.isArray(safeStats.timeline) ? safeStats.timeline : []; // Готовим безопасный массив таймлайна
      activeMembersEl.textContent = safeStats.invites ?? 0; // Обновляем количество активных участников
      messagesEl.textContent = safeStats.messages ?? 0; // Обновляем количество сообщений
      chart.data.labels = safeTimeline.map((p) => formatDateTime(p.time)); // Обновляем метки графика в локальном формате
      chart.data.datasets[0].data = safeTimeline.map((p) => p.invites ?? 0); // Обновляем линию активных участников
      chart.data.datasets[1].data = safeTimeline.map((p) => p.messages ?? 0); // Обновляем линию сообщений
      chart.update(); // Перерисовываем график
      if (safeStats.range_minutes && timeRangeSelect) { // Если в ответе есть диапазон и селектор существует
        selectedRange = Number(safeStats.range_minutes); // Обновляем выбранный диапазон
        timeRangeSelect.value = String(safeStats.range_minutes); // Синхронизируем значение селектора
      } // Конец проверки диапазона
    } // Конец функции

    function formatStorageSize(bytes) { // Функция форматирования размера в удобные единицы
      if (!bytes || bytes <= 0) { // Проверяем наличие значения
        return '0 КБ'; // Возвращаем плейсхолдер для пустого размера
      } // Конец проверки пустого значения
      const units = ['Б', 'КБ', 'МБ', 'ГБ', 'ТБ']; // Массив единиц измерения
      let size = bytes; // Текущее значение размера
      let index = 0; // Индекс текущей единицы измерения
      while (size >= 1024 && index < units.length - 1) { // Пока размер превышает порог и есть единицы крупнее
        size /= 1024; // Переводим в следующую единицу
        index += 1; // Сдвигаем индекс единицы
      } // Конец цикла перевода
      const rounded = index === 0 ? Math.round(size) : Math.round(size * 10) / 10; // Округляем: байты до целого, остальное до десятых
      return `${rounded} ${units[index]}`; // Возвращаем строку с числом и единицей
    } // Конец функции форматирования размера

    function renderStorage(storage) { // Функция вывода информации о файле базы
      storagePathEl.textContent = storage.path || '—'; // Показываем путь до файла
      storageSizeEl.textContent = formatStorageSize(storage.size_bytes || 0); // Показываем размер с автоматическим выбором единиц
      storageStatusEl.textContent = storage.exists ? 'Создан и доступен' : 'Файла пока нет'; // Показываем статус
      storageStatusEl.className = storage.exists ? 'text-success' : 'text-warning'; // Меняем цвет статуса
      attachmentsPathEl.textContent = storage.attachments_path || '—'; // Показываем путь до папки вложений
      attachmentsSizeEl.textContent = formatStorageSize(storage.attachments_size_bytes || 0); // Показываем суммарный размер вложений
      attachmentsStatusEl.textContent = storage.attachments_exists ? 'Скачанные вложения найдены' : 'Папка вложений ещё не создана'; // Показываем статус папки вложений
      attachmentsStatusEl.className = storage.attachments_exists ? 'text-success' : 'text-warning'; // Меняем цвет статуса папки вложений
      stickerCachePathEl.textContent = storage.sticker_cache_path || '—'; // Показываем путь к кэшу стикеров
      stickerCacheSizeEl.textContent = formatStorageSize(storage.sticker_cache_size_bytes || 0); // Показываем суммарный размер кэша стикеров
      stickerCacheStatusEl.textContent = storage.sticker_cache_exists ? 'Кэш стикеров готов' : 'Кэш ещё не создан'; // Показываем статус кэша
      stickerCacheStatusEl.className = storage.sticker_cache_exists ? 'text-success' : 'text-warning'; // Меняем цвет статуса кэша стикеров
    } // Конец функции

    function updateImportantBadge(count) { // Функция обновления бейджа важных сообщений
      const safeCount = Number(count) || 0; // Нормализуем значение
      importantBadge.textContent = safeCount; // Выводим число
      importantBadge.className = safeCount > 0 ? 'badge bg-danger fs-6' : 'badge bg-secondary fs-6'; // Меняем цвет по наличию событий
    } // Конец функции бейджа

    function bootstrapPage() { // Инициализация страницы
      renderGroup(initialGroup || {}); // Показываем данные сообщества
      renderConversations(initialConversations || []); // Показываем диалоги
      renderPeers(initialPeers || []); // Показываем стартовые peer_id
      updateMetrics(initialStats || { timeline: [] }); // Показываем метрики
      renderStorage(initialStorage || {}); // Показываем информацию о файле базы
      updateImportantBadge(0); // Сбрасываем бейдж важных сообщений
    } // Конец функции

    async function poll() { // Функция периодического опроса
      try { // Пытаемся отправить запрос
        const alertsUrl = '/api/service-logs?event_type=important&limit=1'; // URL для важных оповещений
        const statsUrl = `/api/stats?range=${selectedRange}`; // Формируем URL статистики с выбранным диапазоном
        const [statsRes, overviewRes, alertsRes] = await Promise.all([fetch(statsUrl), fetch('/api/overview'), fetch(alertsUrl)]); // Запрашиваем статистику, обзор и оповещения
        const stats = await statsRes.json(); // Читаем JSON статистики
        const overview = await overviewRes.json(); // Читаем JSON обзора
        const alerts = await alertsRes.json(); // Читаем JSON оповещений
        updateMetrics(stats); // Обновляем метрики
        renderGroup(overview.group || {}); // Обновляем информацию о сообществе
        renderConversations(overview.conversations || []); // Обновляем диалоги
        renderPeers(overview.peers || []); // Обновляем список чатов
        renderStorage(overview.storage || initialStorage || {}); // Обновляем данные о файле базы
        updateImportantBadge(alerts.total || 0); // Обновляем бейдж важных сообщений
        await fetchLatestMessages(); // Подтягиваем новые сообщения без сброса ленты
      } catch (err) { // В случае ошибки
        console.error('Ошибка обновления дашборда', err); // Пишем ошибку в консоль
      } // Конец обработки ошибки
    } // Конец функции

    peerSelect.addEventListener('change', () => { // Реагируем на выбор чата
      currentPeer = peerSelect.value; // Сохраняем выбранный peer_id
      reloadMessages(); // Перерисовываем таблицу под новый фильтр
      poll(); // Перезапрашиваем метрики и свежие сообщения
    }); // Конец обработчика

    bootstrapPage(); // Запускаем инициализацию
    poll(); // Делаем первый запрос сразу после загрузки страницы
    setInterval(poll, 3000); // Опрос каждые 3 секунды
  </script> <!-- Конец скрипта -->
</body> <!-- Конец тела -->
</html> <!-- Конец документа -->
