# nechaevka_bot

Полноценный мониторинговый бот для сообщества ВКонтакте. Скрипт подключается к Long Poll API, читает входящие события, строит графики в локальном дашборде и **никогда не отправляет сообщения** от лица сообщества. Все переменные лежат в `.env`, есть демо-режим без VK API, а инструкции написаны под VS Code на Windows (можно через Docker Desktop или WSL). Дашборд хранит события в SQLite (`logs.db`), показывает список чатов (`peer_id`) и фильтрует сообщения по выбранному чату.

> Главное правило: бот только читает. Токен хранится локально в `.env`, этот файл не попадает в репозиторий. Все шаги ниже даны так, чтобы их можно было повторить в VS Code на Windows (через Docker Desktop или WSL, если нужно изолировать окружение).

### Коротко о проекте и потенциале
- Мониторинг ВК без риска отправки сообщений: подойдёт, если хотите просто смотреть активность или готовить аналитику.
- Готовый дашборд на Flask + Chart.js с локальным хранением: можно расширять под собственные метрики или подключать к n8n.
- История в SQLite и скачанные вложения на диске: удобно анализировать старые сообщения, пересчитывать графики и экспортировать данные.

## Что умеет
- Читает события из Long Poll и ведет живую статистику по входящим сообщениям.
- Показывает последние сообщения в дашборде с человекочитаемыми подписями (имя чата, отправитель, вложения и текст без технических ID).
- Выводит локальное время для последних сообщений прямо на главной странице, чтобы сразу видеть хронологию чатов.
- Визуализирует динамику сообщений на графике (Chart.js) и обновляет каждые 3 секунды.
- График строится по истории из SQLite и поддерживает переключение диапазона (15 минут, 1/6/24 часа).
- Показывает информацию о сообществе и списке доступных диалогов (только чтение).
- Имеет демо-режим `DEMO_MODE=1`, чтобы посмотреть UI без реального токена.
- Сохраняет все входящие сообщения вместе с вложениями в базу `logs.db`, чтобы можно было анализировать историю.
- Подтягивает названия чатов и имена отправителей через VK API, сохраняя их вместе с оригинальными ID.
- Тянет аватары пользователей и чатов через VK API и выводит их рядом с текстами в дашборде (размер равен строке текста).
- Позволяет выбрать конкретный `peer_id` и смотреть логи только по нужному чату, показывая человекочитаемые названия.
- Все страницы с сообщениями используют бесконечную ленту: при прокрутке вниз автоматически подгружаются старые записи без общего лимита.
- Отображает превью исходного сообщения при ответах: ID, текст, вложения и автора (если удалось получить профиль).
- Помечает, когда пишет другой бот или сообщество (аккуратная плашка «Бот» рядом с именем отправителя), чтобы проще искать автоматические ответы.
- Показывает отдельную страницу `/logs/full` со всеми последними сообщениями (до 1000 строк) и фильтром по чату.
- Позволяет удалять отдельные строки логов сообщений прямо со страницы `/logs/full`, если нужно убрать конкретную запись.
- Даёт отдельные страницы профиля для каждого чата (`/chat/<peer_id>`) и пользователя (`/user/<id>`), на которых собраны все сообщения и статистика; на имя чата или автора можно кликнуть из любого списка.
- Поднимается локально или в Docker/Compose, пробрасывая порт дашборда.
- Записывает сервисные события (старт, выдача эндпоинтов, ошибки загрузки данных) в отдельный файл `data/service.log` с ротацией и русскими пояснениями кодов статусов.
- Сохраняет сервисные оповещения (warning/error) в базу `logs.db` с локальным временем, поддерживает очистку через POST `/api/service-logs/clear` и выводит их в UI.
- Кнопка «Перейти к оповещениям» сразу открывает вкладку «Сервисные логи» с включённым фильтром «Важные», так что не нужно вручную переключаться после перехода.
- Сохраняет все вложения (фото, документы, видео, голосовые) в иерархию `data/attachments/<peer_id>/<message_id>`, добавляя путь к скачанным файлам в JSON логов; голосовые аудио остаются на диске для последующей расшифровки.
- Показывает галерею вложений прямо в UI: кликайте на бейджи фото/видео/документов, чтобы открыть модалку с описанием отправителя, чата и ссылкой на локальный файл.
- Любые успешно полученные вложения (ссылки, документы, стикеры, аудио и посты) открываются в общей галерее: для каждого типа есть свой просмотрщик, чтобы можно было увидеть содержимое без лишних вкладок.
- При закрытии окна галереи видео полностью останавливается, поэтому звук не продолжается после закрытия модалки.
- Подсвечивает незавершённые загрузки вложений бейджем «⏳ Вложения сохраняются», чтобы видно было, что файл ещё в пути.
- Если файл не сохранился (нет прямой mp4-ссылки или скачивание упало), показывает красный бейдж, пишет причину сбоя и оставляет ссылку на плеер VK, чтобы сразу понять проблему и открыть вложение вручную.
- При отсутствии прямого mp4 видео скачивается через `yt-dlp` по ссылке на плеер VK, поэтому даже закрытые ролики можно сохранить локально, если установлен дополнительный модуль.
- Если в payload видео нет ни mp4, ни плеера, бот собирает ссылку вида `https://vk.com/video<owner_id>_<id>` (с `access_key`, если нужен) и тоже пробует скачать ролик через `yt-dlp` вместо мгновенного отказа.
- Если `yt-dlp` отвечает ошибкой `Access restricted`, бот фиксирует это в логах, помечает вложение кодом 403 и пишет, что нужен корректный `access_key` или авторизация, чтобы сразу понять причину.
- Лонгпулл умеет скачивать видео, но только если у токена есть права на ролик: открытые видео приходят с прямыми mp4, приватные требуют актуальный `access_key` (он есть в ссылке вида `?access_key=...`), иначе VK отдаёт лишь страницу и `yt-dlp` вернёт «Access restricted».
- Очистка логов сообщений и сервисных оповещений дополнительно запускает VACUUM, сжимая `logs.db`, а в дашборде размер базы показывается автоматически в КБ/МБ/ГБ.
- Все виды вложений отображаются с подсказками и эмодзи по типу (фото, видео, документы, ссылки и т.д.), чтобы сразу понимать, что именно отправили.
- Все таблицы с чатами и историями используют еще более компактный шрифт, фиксированную сетку колонок и запрет переносов в ключевых колонках (время, чат, отправитель), поэтому заголовки и подписи всегда умещаются в одну линию; длинные значения обрезаются многоточием без роста высоты строки, а явные классы `col-*` задают стабильную ширину, чтобы текст не уезжал за экран.
- Унифицированный модуль истории чата (`static/js/chat-history.js`) выводит строки сообщений, превью ответов и бейджи вложений одинаково на главной, в `/logs/full` и на страницах профилей.
- Удаленные сообщения подсвечиваются красноватым оттенком в истории, чтобы сразу видеть, что пользователь убрал текст или вложения.
- История выглядит как привычный мессенджер: аватар слева, подписи чата и времени сверху, вложения и ответы собираются в один «пузырь», чтобы читать диалог было комфортнее.
- Аватар в ленте теперь выводится отдельным кружком без подписи, а имя остаётся внутри пузыря, чтобы не повторять отправителя дважды и экономить место.
- Пустые блоки скрываются: превью ответа и вложения показываются только если есть данные, поэтому карточки выглядят компактно и ничего не съезжает.
- ⚠️ Важное ограничение VK: сообщество не получает события об удалении сообщений через Long Poll/Callback API. Если пользователь удалил своё сообщение в чате, VK не шлёт отдельный ивент, поэтому бот физически не узнает об удалении и не может автоматически подсветить сохранённую строку как удалённую. Чтобы увидеть удаление, нужен пользовательский long poll от имени человека или периодическое сравнение истории сообщений внешними скриптами.

### Как выглядят стикеры во вложениях
- В API сообщение приходит с типом `"sticker"` и блоком `sticker`, где есть `sticker_id`, `product_id`, массив `images` (список PNG/WebP вариантов с шириной/высотой) и иногда `images_with_background`.
- Эти же поля сохраняются в `payload` строки события в базе `logs.db` и попадают в фронтенд без изменения структуры — галерея берет самые большие размеры из `images`, чтобы открыть стикер как обычную картинку.
- Если стикер по каким-то причинам пришел без картинок, в логах всё равно останется `sticker_id` и `product_id`, так что по ним можно найти оригинальный набор в каталоге стикеров.
- При первом появлении стикера бот пробует сохранить его изображение в кэш `data/attachments/stickers/sticker_<id>.<ext>`: сначала берет самое большое изображение из `images`, а если ссылки нет, перебирает публичные адреса вида `https://vk.com/sticker/<id>-512-512-0/1` на всякий случай.
- Когда тот же `sticker_id` приходит повторно, бот сразу отдает локальный файл из кэша без повторного скачивания, а при отсутствии ссылок записывает ошибку в сервисные логи, чтобы было понятно, почему картинка не загрузилась.
- Если в одном сообщении приходит один и тот же `sticker_id` несколько раз, в дашборде показывается одна миниатюра: дубликаты отфильтровываются по ID, чтобы не засорять список вложений.
- В таблицах истории и логов стикеры выводятся как маленькие превью с подписью полного `sticker_id`, чтобы сразу видеть, какой стикер прилетел, не открывая галерею.
- Если в сообщении только стикеры, то в колонке вложений сразу показываются миниатюры с их `sticker_id` без лишних бейджей "Стикер ×N": так быстрее увидеть содержимое, не открывая галерею.
- Если открываете старые логи, в которых стикеры ранее не скачивались, просмотр истории сам попробует дотянуть картинку по `sticker_id` из кэша или публичной ссылки VK и положит её в `data/attachments/stickers`, чтобы повторные открытия страницы не тянули сеть.

### Краткая инструкция для тебя (без технических терминов)
1. Открой VS Code и склонируй проект или распакуй архив в удобную папку.
2. Запусти команду установки зависимостей (ниже есть блок «Подготовка окружения»), дождись окончания без ошибок.
3. Создай файл `.env` по примеру и заполни токен/ID группы ВК — токен никому не показывай.
4. Запусти `python app.py` (или Docker Compose), открой в браузере `http://127.0.0.1:8000` и смотри дашборд.
5. В главном экране останется карточка «Сообщения», так что интерфейс станет просторнее и удобнее.

### Напоминание для себя как разработчика
- Всегда добавляй комментарии к каждой строке кода на русском языке, чтобы интерфейс оставался понятным владельцу.
- Не возвращай модуль «Участники» и «Ошибки» на главную страницу — ошибки уже видны в разделе логов, а модуль участников будет разработан позднее.
- Поддерживай демо-режим: он помогает быстро показать обновлённую верстку без подключения к VK API.
- Для любых таблиц сообщений и репостов подключай `static/js/chat-history.js`, чтобы ячейки чатов, отправителей, ответов и вложений выглядели одинаково во всех разделах.

### Что дает база логов
- В файле `logs.db` лежат все события типа `message` с полным payload VK (текст, вложения, ответы).
- Таблица `events` хранит имя чата (`peer_title`), имя отправителя (`from_name`), оригинальные ID, флаг бота и полный payload; её можно открыть через любой SQLite-клиент или встроенную панель VS Code.
- Фильтр в UI использует эти данные, но вы можете подключить `logs.db` к n8n/метрикам или экспортировать в CSV.
- По умолчанию файл лежит в `./data/logs.db` (папка создается автоматически, пробрасывается на хост в Docker и отображается в блоке «Файл логов событий» на дашборде). Если хотите положить в другое место, задайте `EVENT_DB` или пару `EVENT_DB_DIR`+`EVENT_DB_NAME`.
- Страница `/logs/full` грузит логи напрямую из `logs.db` и поддерживает фильтр `peer_id`, а история догружается бесконечной лентой при прокрутке вниз.
- Там же добавлен блок «Сервисные оповещения» с кнопкой очистки и фильтром по уровню (info/warning/error/important); данные подтягиваются через `/api/service-logs` с параметрами `event_type`, `limit`, `offset`.
- Для экономии места в `logs.db` теперь сохраняются только предупреждения и ошибки, а информационные 200-события остаются в файле `data/service.log` с ротацией — так база не распухает от частых успешных обращений.
- Значение по умолчанию для графика задаётся переменной окружения `TIMELINE_DEFAULT_MINUTES` (если не указана, берётся 1440 минут), переключатель есть прямо на главной странице.
- Вложения из сообщений складываются в папку `data/attachments` (или путь из `ATTACHMENTS_DIR`), для каждого сообщения создается подпапка с `peer_id` и `message_id`. Файлы остаются на диске — их можно открывать вручную, подключать к n8n или прогонять через сторонние сервисы для расшифровки голосовых.
- Вложения из сообщений складываются в папку `data/attachments` (или путь из `ATTACHMENTS_DIR`), для каждого сообщения создается подпапка с `peer_id` и `message_id`. Файлы остаются на диске — их можно открывать вручную, подключать к n8n или прогонять через сторонние сервисы для расшифровки голосовых. На дашборде доступна кнопка для открытия каждого вложения через встроенный роут `/attachments/...`.
- На главной странице видно, сколько место занимают вложения и где находится их папка, чтобы сразу понимать нагрузку на диск.
- Карточка хранилища на главной показывает путь и размер базы, скачанных вложений и кэша стикеров отдельными колонками, чтобы было видно, что забирает больше места.

### Как считается график активности
- По умолчанию дашборд показывает последние 24 часа (`TIMELINE_DEFAULT_MINUTES=1440`), другие опции выбираются из выпадающего списка.
- Точки строятся по реальному времени отправки из payload VK: если есть UNIX или ISO-таймштамп, он используется в приоритете.
- Диапазон разбивается на равные корзины (минутные/часовые в зависимости от выбранного диапазона), поэтому скачки и часы без сообщений видны сразу.
- Корзины создаются заранее по фиксированной сетке: пропущенные часы остаются с нулём, а всплески активности поднимают линию вместо ровной прямой.
- Линия визуально плавная за счёт интерполяции, но значения остаются целыми: каждый пик соответствует фактическому числу сообщений в корзине без усреднения.

## Подготовка окружения (с нуля)
1. **Установите Python 3.10+**. На Windows удобнее скачать с https://www.python.org/downloads/ и поставить галочку «Add Python to PATH».
2. **Скачайте проект** (кнопка Code → Download ZIP или `git clone` если установлен git).
3. **Создайте виртуальное окружение**, чтобы зависимости не смешивались с системой:
   ```bash
   python -m venv .venv
   .venv\Scripts\activate  # Windows (PowerShell)
   # source .venv/bin/activate  # Если вы в WSL или Linux
   ```
4. **Установите все модули одной командой** (нужен интернет):
   ```bash
   pip install -r requirements.txt
   ```
   Если появилось сообщение, что модуль не найден — просто повторите команду; она подтягивает все зависимости сразу.
   `yt-dlp` подтянется автоматически: он нужен, чтобы скачивать видео по ссылке плеера VK, когда прямой mp4 недоступен.
5. **Создайте собственный `.env`, не коммитя его в git**:
   - Скопируйте пример: `copy .env.example .env` (Windows PowerShell) или `cp .env.example .env` (WSL/Linux).
   - Заполните файл без кавычек:
     ```
     VK_GROUP_TOKEN=vk1.a.пример_длинного_токена
     VK_GROUP_ID=123456
     PORT=8000
     DEMO_MODE=0
     ```
   - `VK_GROUP_TOKEN` — токен с правами «Сообщения сообщества» (Настройки → Работа с API → Создать ключ).
   - `VK_GROUP_ID` — числовой ID без `club`/`public`. Если адрес `vk.com/club123456`, пишем `123456`.
   - `.env` уже в `.gitignore`, поэтому не попадет в коммиты. Перед `git add` можно проверить `git status`.

## Запуск
1. Активируйте виртуальное окружение и выполните:
   ```bash
   python app.py
   ```
2. Держите окно терминала открытым: там будут логи VK API.
3. Откройте `http://127.0.0.1:8000`:
   - Главная страница — дашборд: карточки метрик, график событий, таблицы последних сообщений и диалогов.
   - `/api/stats` — JSON статистики (можно подключить к n8n или другой автоматизации).
   - `/api/overview` — JSON с данными сообщества и диалогов.
4. Если окно терминала закрывается при двойном клике по `app.py`, откройте VS Code → Terminal → `python app.py`. При ошибке окно не закроется сразу, можно прочитать текст.
5. Для просмотра сырых логов можно зайти на `http://127.0.0.1:8000/api/logs` или добавить `?peer_id=XXX`, чтобы получить JSON по конкретному чату.

### Демо-режим (без токена)
- В `.env` поставьте `DEMO_MODE=1`, остальные поля можно не заполнять.
- Запустите `python app.py` — увидите UI с примерными данными и графиком.
- Чтобы вернуться к реальному VK, смените `DEMO_MODE` на `0` и заполните `VK_GROUP_TOKEN`/`VK_GROUP_ID`.

### Частые причины «сервер не открывается»
- Не заполнены `VK_GROUP_TOKEN` или `VK_GROUP_ID` — приложение упадет с подсказкой в консоли.
- Порт `8000` занят: поменяйте `PORT` в `.env` или левую часть в `docker-compose.yml` (например, `8001:8000`).
- Файрвол блокирует вход: добавьте исключение для `python.exe` или Docker Desktop.
- Нет интернета или VK API недоступен: в логах будет предупреждение, дашборд поднимется с пустыми данными.

### Если ругается на «модуль не установлен»
- Проверьте, что активировано виртуальное окружение (`.venv`).
- В активном окружении повторно выполните `pip install -r requirements.txt`.
- Можно запустить автоматизацию на Windows:
  ```powershell
  powershell -ExecutionPolicy Bypass -File .\install_all.ps1
  ```

## Запуск через Docker (Desktop или WSL)
1. Установите Docker Desktop и убедитесь, что демон запущен.
2. Создайте `.env` в корне (как в инструкции выше). Файл не попадет в образ, но будет передан в контейнер.
3. Запуск через Docker Compose (сборка + старт):
   ```bash
   docker compose up --build
   ```
   - Если порт 8000 занят, поменяйте левое число в `docker-compose.yml`, например `"8001:8000"`.
   - База логов лежит на хосте в `./data/logs.db` (папка появится рядом с проектом). Файл можно открыть из VS Code на Windows или подключить к n8n.
4. Ручной запуск:
   ```bash
   docker build -t nechaevka_bot_image .
   docker run --env-file .env -p 8000:8000 --name nechaevka_bot nechaevka_bot_image
   ```
5. Откройте `http://127.0.0.1:8000` и смотрите дашборд.

### Зачем Docker в этом проекте
- Изоляция: код и зависимости в одном образе, система не засоряется.
- Повторяемость: на любой машине с Docker получите одинаковый результат.
- Простая очистка: удалили контейнер/образ — удалили следы.

## Потенциал
- Хранить события в базе и строить исторические графики.
- Добавить фильтры по чатам/ID и экспорт в CSV.
- Подключить алерты (webhook или n8n) по ошибкам лонгпулла.
